---
title: "Analysis of scaled flows" 
author: "Galen Holt" 
---

We've [pulled historical flow data](pull_gauges_to_scale.qmd), and after a lot of [methods testing](flow_scaling_methods.qmd), have settled on a combination of quantile-quantile scaling and linear regression. This is implemented with functions in `scaling_functions.R`, and the [scaling notebook](scaling_scenarios.qmd) applies these scalings to all gauges in the EWR tool, saves hydrographs as csvs in a standard directory structure, and also saves the scaled hydrographs as an `rds` file to make it easier to pull them back in here to analyse.

The main goal is to run those scaled hydrographs through the toolkit, but we also wan to do some analyses of the scaled hydrographs. There's quite a lot we might want to do to analyse them in terms of calculating hydrometrics, etc. But for now I'll just make some descriptive figures and tables to assess what they look like.

```{r}
#| message: false 
library(werptoolkitr) 
library(dplyr) 
library(tidyr) 
library(lubridate) 
library(ggplot2)

source('scenario_creation/scaling_functions.R')
```

## Setup

Paths

```{r}
scenario_dir <- '../flow_scaling_data' 
hydro_dir <- file.path(scenario_dir, 'hydrographs') 
scaling_dir <- file.path(scenario_dir, 'CC_Scenarios_WRPs')
```

Read in the data. It's saved as an RDS, and includes the hydrographs themselves in the Historical scenario.

```{r}
scaled_hydros <- readRDS(file.path(hydro_dir, 'scaled_hydrographs.rds')) 
```

Get the scenario metadata- format is likely to change, but let's try to at least move towards this sort of file-based recording

```{r}
scenario_meta <- yaml::read_yaml(file.path(hydro_dir, 'scaling_metadata.yml'))
```

Let's set up some formatting- likely need this somewhere even more general

```{r}
scaling_scene_pal <- make_pal(scenario_meta$scenario_name, 
                              palette = 'RColorBrewer::YlGnBu', 
                              refvals = c('Historical', 'SimR0'), 
                              refcols = c('firebrick', 'darkorchid3'), 
                              includeRef = TRUE)
```

# Structure

There are a lot of hydrometrics we will want to calculate, but for now we're mostly focused on describing how the distributions change, typically in two ways-

1.  between the true hydrograph and baseline, to capture the effects of the transforms and
2.  between the different scenarios to capture the impacts of climate

We'll start out by looking at a few fairly obvious comparisons

-   Timeseries

-   probability distribution of values,

-   Number of zeros

-   and add more as we go

The EWR tool and the directory structure are set up to look at all the gauges within scenarios, and then compare, but the rds here is set up do to scenario comparisons within gauges, which is really what we want to do here (and what the Comparer is tuned for as well).

We *do* want to look at these for all the gauges, but that is going to be a TON of output. There's likely a good way to organise it, but I guess for now I'll just `purrr` over the data and return the results and end up with a really long document. Obviously if we didn't want to check each gauge, we'd choose a representative example or two and use that.

# Timeseries

basically, purrr over this, but I think drop the zero points, they're hard to see and we'll just count them next.

```{r}
scaled_hydros[['409003']] %>% 
                   unnest(cols = data) %>%
                   pivot_longer(cols = 3, names_to = 'gauge', 
                                values_to = 'flow') %>% 
plot_hydrographs(y_col = 'flow',
                 colors = scaling_scene_pal) +  
  facet_wrap('scenario') + 
  geom_point(mapping = aes(y = 0, color = (flow == 0)))
```

A function to purrr

```{r}
timefun <- function(data, gaugename) {
  
  if (is.null(data)) {return(NULL)}
  timeplot <- data %>% 
    unnest(cols = data) %>%
    pivot_longer(cols = 3, names_to = 'gauge',
                 values_to = 'flow') %>% 
    plot_hydrographs(y_col = 'flow',
                     colors = scaling_scene_pal) +  
    facet_wrap('scenario') +
    ggtitle(gaugename)
  
  return(timeplot)
}
```

Save the plots as a list

```{r}
time_plotlist <- purrr::map2(scaled_hydros,
                             names(scaled_hydros),
                             \(x,y) timefun(x, y))
```

Print them. I'm guessing this is going to blow everything up.

```{r}
purrr::map(time_plotlist, print)
```

# Zeros

Basically, purrr over this

```{r}
scaled_hydros[['420020']] %>% 
                   unnest(cols = data) %>%
                   pivot_longer(cols = 3, names_to = 'gauge', 
                                values_to = 'flow') %>% 
  group_by(scenario) %>% 
  summarise(n_zero = sum(flow == 0, na.rm = TRUE))
```

Function to purr.

```{r}
zerofun <- function(data, gaugename) {
  
  if (is.null(data)) {return(NULL)}
  zeros <- data %>% 
    unnest(cols = data) %>%
    pivot_longer(cols = 3, names_to = 'gauge',
                 values_to = 'flow') %>% 
    group_by(scenario) %>% 
  summarise(n_zero = sum(flow == 0, na.rm = TRUE)) %>% 
    mutate(gauge = gaugename)
  
  return(zeros)
}
```

This is going to be small, so I think I'll purrr and then bind_rows to make a df instead of a list

```{r}
zerodf <- purrr::map2(scaled_hydros,
                             names(scaled_hydros),
                             \(x,y) zerofun(x, y)) %>% 
  bind_rows()
```

Is there a good way to plot that? Not really. I'm not going to spend much time trying to make this pretty.

```{r}
ggplot(zerodf, aes(x = scenario, y = n_zero, color = gauge)) + 
  geom_point() + 
  geom_line(aes(group = gauge)) + 
  scale_y_continuous(trans = 'pseudo_log') + 
  theme_werp_toolkit() + 
  theme(legend.position = 'none')
```

The historical and baseline data have different zeros sometimes because of the way the regressions play out across months, particularly if the relationship is very flat. I have introduced a correction to ensure we get zeros for runoff values that rank with 0 flow values, even if the regression is flat enough that the predictions are slightly positive.

# PDFs

I'm going to look at these on the log scale, otherwise they;re unreadable.

```{r}
pdffun <- function(data, gaugename) {
  
  if (is.null(data)) {return(NULL)}
  
 pdfplot <- data %>% 
    unnest(cols = data) %>%
    pivot_longer(cols = 3, names_to = 'gauge',
                 values_to = 'flow') %>% 
    ggplot(aes(x = log(flow + 1), color = scenario)) + 
   geom_density() + scale_color_manual(values = scaling_scene_pal) +
    ggtitle(gaugename) +
   theme_werp_toolkit()
  
  return(pdfplot)
}
```

Save as a list

```{r}
pdf_plotlist <- purrr::map2(scaled_hydros,
                             names(scaled_hydros),
                             \(x,y) pdffun(x, y))
```

Print

```{r}
purrr::map(pdf_plotlist, print)
```

# CDFs

```{r}
cdffun <- function(data, gaugename) {
  
  if (is.null(data)) {return(NULL)}
  
 cdfplot <- data %>% 
    unnest(cols = data) %>%
    pivot_longer(cols = 3, names_to = 'gauge',
                 values_to = 'flow') %>% 
    ggplot(aes(x = log(flow + 1), color = scenario)) + 
   stat_ecdf() + 
   scale_color_manual(values = scaling_scene_pal) +
    ggtitle(gaugename) +
   theme_werp_toolkit()
  
  return(cdfplot)
}
```

Save list

```{r}
cdf_plotlist <- purrr::map2(scaled_hydros,
                             names(scaled_hydros),
                             \(x,y) cdffun(x, y))
```

Print

```{r}
purrr::map(cdf_plotlist, print)
```

# Q-Q relative change

If I were just doing pure q-q, we could make these as we go from the q-q scaling, but I don't for two reasons- I want to incorporate the final data including the regressions, and I want to output clean data from the [scaling notebook](scaling_scenarios.qmd), not clutter it up with plots.

We have the code to do this in the scaling functions. I could spend time generalising, but I think I won't for now.

Split by month (as it was actually done)

```{r}

# month_q <- scaled_hydros[['409003']] %>% 
#                    unnest(cols = data) %>%
#                    pivot_longer(cols = 3, names_to = 'gauge', 
#                                 values_to = 'flow') %>%
#   dplyr::mutate(Month = lubridate::month(Date)) %>% 
#     dplyr::group_by(scenario, Month) %>%
#     dplyr::summarise(qmean = get_qmean(flow, q_perc = 0.02),
#                      .groups = 'drop') %>%
#     # reframe is the new way, but needs dplyr 1.1 which breaks lots of the functions
#     # reframe(qmean = get_qmean(runoff)) %>%
#     tidyr::unnest(cols = qmean) %>%
#     # dplyr::group_by(scenario, Month) %>%
#     baseline_compare(compare_col = 'scenario',
#                      base_lev = 'SimR0',
#                      values_col = 'mean',
#                      group_cols = c('Month', 'quantile'),
#                      comp_fun = `/`) %>%
#     dplyr::ungroup() %>%
#     dplyr::rename(relative_change = `/_mean`)
  
qfun <- function(data, gaugename) {
  
  if (is.null(data)) {return(NULL)}
  
 month_q <- data %>% 
                   unnest(cols = data) %>%
                   pivot_longer(cols = 3, names_to = 'gauge', 
                                values_to = 'flow') %>%
  dplyr::mutate(Month = lubridate::month(Date, label = TRUE)) %>% 
    dplyr::group_by(scenario, Month) %>%
    dplyr::summarise(qmean = get_qmean(flow, q_perc = 0.02),
                     .groups = 'drop') %>%
        tidyr::unnest(cols = qmean) %>%
        baseline_compare(compare_col = 'scenario',
                     base_lev = 'SimR0',
                     values_col = 'mean',
                     group_cols = c('Month', 'quantile'),
                     comp_fun = `/`) %>%
    dplyr::ungroup() %>%
    dplyr::rename(relative_change = `/_mean`)
 
 qplot <- ggplot(month_q, mapping = aes(x = quantile, 
                       y = relative_change, color = scenario)) + 
  geom_line() + 
    scale_color_manual(values = scaling_scene_pal) +
  facet_wrap('Month') + 
   coord_cartesian(ylim = c(0.25, 1.5)) + 
   theme_werp_toolkit()
  
  return(qplot)
}
```

Make the list

```{r}
q_plotlist <- purrr::map2(scaled_hydros,
                             names(scaled_hydros),
                             \(x,y) qfun(x, y))
```

Print

```{r}
purrr::map(q_plotlist, print)
```

We could not split by month to make it easier to see, but it's not actually what we did, and it loses some of the more striking disproportionate scaling across quantiles.

```{r}
#| eval: false

all_q <- scaled_hydros[['409003']] %>% 
                   unnest(cols = data) %>%
                   pivot_longer(cols = 3, names_to = 'gauge', 
                                values_to = 'flow') %>%
    dplyr::group_by(scenario) %>%
    dplyr::summarise(qmean = get_qmean(flow, q_perc = 0.02),
                     .groups = 'drop') %>%
    # reframe is the new way, but needs dplyr 1.1 which breaks lots of the functions
    # reframe(qmean = get_qmean(runoff)) %>%
    tidyr::unnest(cols = qmean) %>%
    # dplyr::group_by(scenario, Month) %>%
    baseline_compare(compare_col = 'scenario',
                     base_lev = 'SimR0',
                     values_col = 'mean',
                     group_cols = c('quantile'),
                     comp_fun = `/`) %>%
    dplyr::ungroup() %>%
    dplyr::rename(relative_change = `/_mean`)

  ggplot(all_q, mapping = aes(x = quantile, 
                       y = relative_change, color = scenario)) + 
  geom_line() + 
    scale_color_manual(values = scaling_scene_pal) +
    coord_cartesian(ylim = c(0.25, 1.5))
```

# notes 

When we go to use this, we should check the zeros, and only use scenarios with zeros \>= SimR0.
