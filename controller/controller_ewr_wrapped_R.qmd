---
title: "Scenario controller"
author: "Galen Holt"
format:
  html:
    df-print: paged
editor: visual
cache: false
params:
  REBUILD_DATA: FALSE
---

```{r}
#| echo: false

# params don't get seen in interactive running, so handle that.
if ("params" %in% ls()) {
  REBUILD_DATA <- params$REBUILD_DATA
} else {
  REBUILD_DATA <- FALSE
}
```

Load the package

```{r}
library(werptoolkitr)
```

The controller primarily sets the paths to scenarios, calls the modules, and saves the output and metadata. In normal use, we set the directory and any other needed parameters (e.g. point at a config file), and the controller functions auto-generate the folder structure, run the ewr, and output the results. This can be taken up a level to the [the whole toolkit](full_toolkit/full_toolkit_overview.qmd), where the controller and subsequent steps are all run at once. A [detailed stepthrough](controller/controller_ewr_stepthrough.qmd) of what happens in the controller is also available, useful to see what is happening under the hood.

# Setup

There are a few bits of info the user needs to set for a particular run. These can be set here, or done in a parameters `.yaml` file (though that's still buggy). These needed bits of information for the controller are the location of the data and the sort of output desired.

## Set paths

We need to set the path to this demonstration. This should all be in a single outer directory `project_dir`, and there should be an inner directory with the input data `/hydrographs`. These would typically point to external shared directories. For this simple example though, we put the data inside the repo to make it self contained. The saved data goes to `project_dir/module_output` automatically. The `/hydrographs` subdirectory could be made automatic as well, but I'm waiting for the input data format to firm up.

```{r}
project_dir = file.path('scenario_example')
hydro_dir = file.path(project_dir, 'hydrographs')
```

## Control output and return

To determine what to save and what to return to the active session, use `outputType` and `returnType`, respectively. Each of them can take a list of any of `'none'`, `'summary'`, `'annual'`, `'all'`, with more I need to add to reflect new EWR functionality (e.g. `returnType = list('summary', 'all')` in R or `returnType = ['summary', 'all]` in python). These have to be lists to work right- To make a `list` in python, need to have unnamed lists in R.

*There's an issue with* `'annual'` *in py-ewr- I'm getting an error inside the EWR tool. Until I updated the EWR version, skip that.*

```{r}
returnType <- list('summary', 'all')

# We use outputtype to save, so only save outputs if params$REBUILD_DATA is TRUE
# To make a list in python, need to have unnamed lists in R
if (!REBUILD_DATA) {
  outputType <- list('none')
}
if (REBUILD_DATA) {
  outputType <- list('summary', 'all')
}
```

## Run and save

The above is all user parameters. All the formatting, running, and saving is then handled with the wrapper function `prep_run_save_ewrs`. See [stepthrough](controller/controller_ewr_stepthrough_R.qmd) for an expanded version used to run test data and expand each step to make testing/changes more transparent.

```{r}
ewr_out <- prep_run_save_ewrs_R(scenario_dir = hydro_dir, output_dir = project_dir, outputType = outputType, returnType = returnType)
```

Now we have a `summary` and `all`.

```{r}
#| rows.print = 20
ewr_out$summary
```

```{r}
#| rows.print = 20
ewr_out$all
```

# Next steps

This now has the EWR outputs saved into `scenario_dir/module_output/EWR` and available for further processing with the aggregator.