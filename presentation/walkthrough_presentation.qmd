---
title: "HydroBOT walkthrough"
format:
  revealjs: 
    theme: default
echo: true
---

```{r}
#| include: false
source("R/helpers.R")
make_hydro_csv()
```

## Full HydroBOT run

```{r}
#| message: false
library(HydroBOT)
library(sf)
library(dplyr)

```

-   Many options we could set

-   See options at [github pages site](https://special-disco-eyonrvy.pages.github.io/){target="_blank"} for [HydroBOT_website](https://github.com/MDBAuth/HydroBOT_website){target="_blank"}

-   Can run with minimal arguments

# User arguments

-   Paths to input

-   Paths to save output

-   Module arguments (minimal)

-   Aggregation sequence and functions

## Paths

```{r}
# Outer directory for scenario
project_dir <- file.path("hydrobot_scenarios")

# Hydrographs (expected to exist already)
hydro_dir <- file.path(project_dir, "hydrographs")

# Generated data
# EWR outputs (will be created here in controller, read from here in aggregator)
ewr_results <- file.path(project_dir, "module_output", "EWR")

# outputs of aggregator. There may be multiple modules
agg_results <- file.path(project_dir, "aggregator_output")
```

## EWR controls

-   Other modules as they are available

```{r}
outputType <- list("yearly")
returnType <- list("none") 
```

## Aggregation sequencing {.smaller}

-   Sequence of steps

-   Sequence of functions

```{r}
aggseq <- list(
  all_time = 'all_time',
  ewr_code = c("ewr_code_timing", "ewr_code"),
  env_obj = c("ewr_code", "env_obj"),
  sdl_units = sdl_units,
  Specific_goal = c("env_obj", "Specific_goal"),
  catchment = cewo_valleys,
  Objective = c("Specific_goal", "Objective"),
  mdb = basin,
  target_5_year_2024 = c("Objective", "target_5_year_2024")
)


funseq <- list(
  'ArithmeticMean',
  c("CompensatingFactor"),
  c("ArithmeticMean"),
  c("ArithmeticMean"),
  c("ArithmeticMean"),
  'SpatialWeightedMean',
  c("ArithmeticMean"),
  'SpatialWeightedMean',
  c("ArithmeticMean")
)
```

# Run HydroBOT

Typically automatically

-   Run hydrographs through modules

-   Aggregate and save responses

-   Comparisons/analyses

## Module

-   Currently just EWR

-   Where are hydrographs

-   Where to save output

```{r}
ewr_out <- prep_run_save_ewrs(
  hydro_dir = hydro_dir,
  output_parent_dir = project_dir,
  outputType = outputType,
  returnType = returnType
)
```

## Aggregator

Returning instead of saving for presentation

-   Sequence (levels of each theme, space, time axis)

-   Aggregation functions at each step

```{r}
agged_data <- read_and_agg(
  datpath = ewr_results,
  type = "achievement",
  geopath = bom_basin_gauges,
  causalpath = causal_ewr,
  groupers = "scenario",
  aggCols = "ewr_achieved",
  aggsequence = aggseq,
  funsequence = funseq,
  saveintermediate = TRUE,
  namehistory = FALSE,
  keepAllPolys = FALSE,
  returnList = TRUE,
  savepath = NULL
)
```

# Outputs

-   Standardised formats using `plot_outcomes` function

-   Different plots for different purposes

-   Small selection follows

```{r}
#| echo: false
#| message: false
# Scenario data
scenarios <- jsonlite::read_json(file.path(
  hydro_dir,
  "scenario_metadata.json"
)) |>
  tibble::as_tibble() |>
  tidyr::unnest(cols = everything()) |> 
  rename(scenario = scenario_name)

sceneorder <- forcats::fct_reorder(scenarios$scenario, 
                                   scenarios$flow_multiplier)

scene_pal <- make_pal(unique(scenarios$scenario),
  palette = "ggsci::nrc_npg",
  refvals = "base", refcols = "black"
)

gauges_to_plot <- c("412002", "419001", "422028", "421001")

gauge_pal <- make_pal(unique(gauges_to_plot),
  palette = "nationalparkcolors::Denali"
)
gauge_pal
```

```{r}
#| echo: false
# make the super long names shorter but less useful.
basin_to_plot <- agged_data$mdb |> 
  dplyr::left_join(scenarios, by = 'scenario')

# Create a grouping variable
obj_sdl_to_plot <- agged_data$sdl_units |>
  dplyr::mutate(env_group = stringr::str_extract(env_obj, "^[A-Z]+")) |>
  dplyr::filter(env_group %in% c('EF', 'NF', 'NV', 'OS', 'WB')) |> 
  dplyr::arrange(env_group, env_obj) |> 
  dplyr::left_join(scenarios, by = 'scenario')
```

## Input hydrographs

```{r}
#| echo: false
#| message: false
scenehydros <- read_hydro(hydro_dir, long = TRUE, 
                          format = "csv")

scenehydros <- scenehydros |> 
  # these have EWR-specific _flow after the gauge name
  mutate(gauge = stringr::str_remove_all(gauge, "_[a-z]*")) |>
  # because gauges are not their own files, we have to filter them on read-in
  filter(gauge %in% gauges_to_plot) |>
  left_join(scenarios)

hydros <- plot_outcomes(scenehydros,
  outcome_col = "flow",
  outcome_lab = "Flow (ML/day)",
  x_col = "Date",
  colorset = "gauge",
  color_lab = "Gauge ID:",
  pal_list = gauge_pal,
  facet_row = "scenario",
  facet_col = "gauge",
)

hydros
```

## Maps and spatial scaling

```{r}
#| message: false
#| echo: false

# Quick plot
map_example <- agged_data$sdl_units |>
  dplyr::filter(env_obj == "NF1") |> # Need to reduce dimensionality
  plot_outcomes(
    outcome_col = "ewr_achieved",
    plot_type = "map",
    colorset = "ewr_achieved",
    pal_list = list("scico::tokyo"),
    facet_col = "scenario",
    facet_row = "env_obj",
    underlay_list = "basin",
    overlay_list = list(
      overlay = dplyr::filter(
        agged_data$env_obj,
        env_obj == "NF1"
      ),
      overlay_pal = "scico::oslo",
      overlay_ycol = "ewr_achieved",
      clip = TRUE
    )
  ) +
  ggplot2::theme(legend.position = "bottom")

map_example
```

## Bars- SDL units and scenarios

SDL unit differences in all environmental objectives

```{r}
#| echo: false
catchcompare <- agged_data$sdl_units |>
  group_by(SWSDLName, scenario) |>
  summarise(ewr_achieved = sum(ewr_achieved, na.rm = TRUE)) |>
  ungroup() |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    colorset = "SWSDLName",
    pal_list = list("calecopal::lake"),
    sceneorder = sceneorder,
    position = "dodge"
  )

catchcompare
```

## Objective and scenario comparisons

::: panel-tabset
### Basin

```{r}
#| echo: false
objective_comp <- plot_outcomes(basin_to_plot,
  outcome_col = "ewr_achieved",
  x_col = "Objective",
  colorset = "scenario",
  pal_list = scene_pal,
  sceneorder = sceneorder,
  position = "dodge"
)

objective_comp
```

### SDL units

```{r}
#| echo: false
#| message: false
# Create a palette list
env_pals <- list(
  EF = "grDevices::Purp",
  NF = "grDevices::Mint",
  NV = "grDevices::Burg",
  OS = "grDevices::Blues",
  WB = "grDevices::Peach"
)

# need to facet by space sdl unit and give it the colorgroup argument to take multiple palettes
sdl_stack <- obj_sdl_to_plot |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    colorgroups = "env_group",
    colorset = "env_obj",
    pal_list = env_pals,
    facet_col = "SWSDLName",
    facet_row = ".",
    sceneorder = sceneorder
  )
sdl_stack +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 0.5))
```
:::

## Lines and baseline

Change relative to baseline available to all plots

-   Disproportionate response

```{r}
#| echo: false

line_pals <- list(
  EF = "scico::acton",
  NF = "scico::bamako",
  NV = "scico::batlow",
  OS = "scico::lajolla",
  WB = "scico::hawaii"
)


sdl_line_groups_facet <- obj_sdl_to_plot |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    x_col = "flow_multiplier",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transoutcome = "log10",
    color_lab = "Environmental\ngroup",
    colorgroup = "env_group",
    colorset = "env_obj",
    pal_list = line_pals,
    facet_row = "SWSDLName",
    facet_col = "env_group",
    sceneorder = sceneorder,
    base_list = list(base_lev = "base",
    comp_fun = "relative",
    add_eps = 'auto',
    group_cols = c("env_obj", "polyID"))
    
  )

sdl_line_groups_facet + ggplot2::theme(legend.position = "none")
```

## Fits

Smoothed fit of all environmental objectives in each group

-   Relative to baseline

```{r}
#| echo: false
#| message: false
sdl_fit_sdl <- obj_sdl_to_plot |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    x_col = "flow_multiplier",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transoutcome = "log10",
    color_lab = "SDL unit",
    colorset = "SWSDLName",
    pal_list = list("ggsci::default_jama"),
    facet_wrapper = "env_group",
    sceneorder = sceneorder,
base_list = list(base_lev = "base",
    comp_fun = "relative",
    add_eps = 'auto',
    group_cols = c("env_obj", "polyID")),
smooth_arglist = list()
  )

suppressWarnings(print(sdl_fit_sdl))
```

## Causal networks

::: panel-tabset
```{r}
#| echo: false
# Which steps are theme? This glosses over potential changes with space
aggseq <- list(all_time = 'all_time',
               ewr_code = c('ewr_code_timing', 'ewr_code'),
               env_obj =  c('ewr_code', "env_obj"),
               Target = c('env_obj', 'Target'))

funseq <- list('ArithmeticMean', 
               'CompensatingFactor',
               'ArithmeticMean',
               'ArithmeticMean')

agged_theme <- read_and_agg(datpath = ewr_results, 
           type = 'achievement',
           geopath = bom_basin_gauges,
           causalpath = causal_ewr,
           groupers = 'scenario',
           aggCols = 'ewr_achieved',
           auto_ewr_PU = TRUE,
           aggsequence = aggseq,
           funsequence = funseq,
           saveintermediate = TRUE,
           namehistory = FALSE,
           keepAllPolys = FALSE,
           returnList = TRUE,
           add_max = FALSE)

example_gauge <- "421001"

edges <- make_edges(causal_ewr,
  fromtos = aggseq[2:length(aggseq)],
  gaugefilter = example_gauge
)

nodes <- make_nodes(edges)
```

```{r}
#| message: false
#| warning: false
#| echo: false

# Get the values for each node
aggvals <- extract_vals_causal(agged_theme,
                               whichaggs = funseq, # Since only one agg function at each step
                               valcol = 'ewr_achieved',
                               targetlevels = names(aggseq)[2:length(aggseq)]) # don't use the first one, it's time at _timing 


# filter to a single gauge. Multiple gauges should have separate networks or otherwise split the gauge-specific nodes. And include the larger scales pertaining to that gauge.

# if we stay within the gauge, and just do value, this works
aggvals <- aggvals |> 
  filter(gauge == example_gauge) |> 
  st_drop_geometry()

# join to the nodes
nodes_with_vals <- dplyr::left_join(nodes, aggvals)
```

### Down 4

```{r}
#| echo: false
aggNetwork_down <- make_causal_plot(
  nodes = dplyr::filter(
    nodes_with_vals,
    scenario == "down4"
  ),
  edges = edges,
                 setLimits = c(0, 1),
  edge_pal = "black",
  node_pal = list(value = "scico::lapaz"),
  node_pal_direction = -1,
  node_colorset = "ewr_achieved",
  render = FALSE
)

DiagrammeR::render_graph(aggNetwork_down)
```

### Baseline

```{r}
#| echo: false
aggNetwork_base <- make_causal_plot(
  nodes = dplyr::filter(
    nodes_with_vals,
    scenario == "base"
  ),
  edges = edges,
                 setLimits = c(0, 1),
  edge_pal = "black",
  node_pal = list(value = "scico::lapaz"),
  node_pal_direction = -1,
  node_colorset = "ewr_achieved",
  render = FALSE
)

DiagrammeR::render_graph(aggNetwork_base)
```

### Up 2

```{r}
#| echo: false
aggNetwork_4 <- make_causal_plot(
  nodes = dplyr::filter(
    nodes_with_vals,
    scenario == "up4"
  ),
  edges = edges,
                 setLimits = c(0, 1),
  edge_pal = "black",
  node_pal = list(value = "scico::lapaz"),
  node_pal_direction = -1,
  node_colorset = "ewr_achieved",
  render = FALSE
)

DiagrammeR::render_graph(aggNetwork_4)
```
:::

# Where next?

::::: columns
::: {.column width="40%"}
-   Real scenarios
    -   Flow scaling

    -   Case study
-   Capacity extension
    -   Modules

    -   Aggregation

    -   Azure/large runs
:::

::: {.column width="60%"}
-   Socialisation
    -   Users/maintainers/builders

    -   Output needs and targets

    -   Links to other programs
:::
:::::

