---
title: "DEMO PAPER Plots"
author: "G Dwyer"
format:
  html:
    df-print: paged
editor: visual
---

```{r}
#| include: false

library(HydroBOT) 
library(ggplot2) 
library(dplyr)
library(sf)
#library(reticulate) # Not strictly necessary but allows easier referencing of objects #needed for gauge locations?
library(patchwork)
library(paletteer)
```

```{r}
#| echo: false
#| include: false

## Input and output directories

# Outer directory for scenario 
project_dir = file.path('more_scenarios')  

# Preexisting data # Hydrographs (expected to exist already) 
hydro_dir = file.path(project_dir, 'hydrographs')  

# Generated data # EWR outputs (will be created here in controller, read from here in aggregator) 
ewr_results <- file.path(project_dir, 'module_output', 'EWR')  

# outputs of aggregator. There may be multiple modules 
agg_results <- file.path(project_dir, 'aggregator_output') 

# outputs of comparer. 
comp_results <- file.path(project_dir, 'comparer_output') 
```

```{r}
#| echo: false
#| include: false

## Scenario information

# Get scenario metadata. This will be auto-found later, but leaving here until it firms up.
# Hydrographs
# Agg data

#scenario metadata
scenarios <- jsonlite::read_json(file.path(hydro_dir,                                             'scenario_metadata.json')) |>    
  tibble::as_tibble() |>    
  tidyr::unnest(cols = everything()) |>
  dplyr::rename('scenario' = "scenario_name")

#Hydrographs
scenehydros <- read_hydro(hydro_dir, long = TRUE, format = 'csv') 

#Agg data
agged_data <- readRDS(file.path(agg_results, 'summary_aggregated.rds'))

# Baselining
# would be good to be able to do both at the same time = comp_fun = c(difference, relative),
dif_flow <- baseline_compare(scenehydros, compare_col = 'scenario',                                             base_lev = "climatebaseadapt0",
                             values_col = 'flow',                               
                             comp_fun = c("difference"),
                             group_cols = c('Date', 'gauge'))

rel_flow <- baseline_compare(scenehydros, compare_col = 'scenario',                                             base_lev = "climatebaseadapt0",
                             values_col = 'flow',                               
                             comp_fun = c("relative"),
                             group_cols = c('Date', 'gauge'))

# Need to calculate delta
# Galen does this:
#scenarios <- tibble::tibble(scenario = scenenames, delta = scenemults)

delta_table <- dif_flow |>
  group_by(scenario) |>
  summarise(delta_diff = sum(difference_flow)/ 10000000) 

# After discussion with Galen - should use relative flow, but thats not working, need to look at the formula.
# delta_table <- rel_flow |>
#   group_by(scenario) |>
#   summarise(delta_diff = sum(relative_flow)) 

unique_Climates <- data.frame(flow_multiplier = sort(unique(scenarios$flow_multiplier)))
unique_Climates$Climate <- c("MAX", LETTERS[1:length(unique(scenarios$flow_multiplier))-1])

unique_AdaptOpt <- data.frame(flow_addition = sort(unique(scenarios$flow_addition)))
unique_AdaptOpt$AdapOpt <- c(1:(length(unique(scenarios$flow_addition))-1), "MAX")

scenarios <- left_join(scenarios, delta_table, by = join_by(scenario))
scenarios <- left_join(scenarios, unique_Climates, by = join_by(flow_multiplier))
scenarios <- left_join(scenarios, unique_AdaptOpt, by = join_by(flow_addition)) |>
  mutate(Climate_AdapOpt = ifelse(Climate == "MAX", "MAX", paste0(Climate, AdapOpt)))

#joining
#need to join scenarios (climate and adaptation)
scenehydros <- left_join(scenehydros, scenarios, by = join_by(scenario))
scenehydros$difference_flow <- dif_flow$difference_flow
scenehydros$relative_flow <- rel_flow$relative_flow


#EWR Tool parameter file
NSWEWR <- read.csv("temporary_files/NSWEWR.csv")

#ORdering
sceneorder <- forcats::fct_reorder(scenarios$scenario, (scenarios$flow_multiplier + scenarios$flow_addition/100000))
sceneorder_label <- forcats::fct_reorder(scenarios$Climate_AdapOpt, (scenarios$flow_multiplier + scenarios$flow_addition/100000))

#tables for doc
unique_Climates <- unique_Climates[order(unique_Climates$Climate),]
unique_Climates <- select(unique_Climates, c(Climate, flow_multiplier))
colnames(unique_Climates) <- c("Climate code","Flow multiplier")
saveRDS(unique_Climates, file = file.path(comp_results, "unique_Climates.Rdata"))

unique_AdaptOpt<- select(unique_AdaptOpt, c(AdapOpt, flow_addition))
colnames(unique_AdaptOpt) <- c("Adaptation Option code","Flow addition")
saveRDS(unique_AdaptOpt, file = file.path(comp_results, "unique_AdaptOpt.Rdata"))

```

```{r}
#| echo: false
#| include: false

## Subset for demo

# We have a lot of hydrographs, so for this demonstration, we will often use a subset.

gauges_to_plot <- c('412002', '419001')#, '422028', '421001')
scenario_to_plot <- c("climatedown2adapt0", "climatedown2adapt201", "climatedown2adapt6001",
                      "climatebaseadapt0", "climatebaseadapt201", "climatebaseadapt6001",
                      "climateup2adapt0", "climateup2adapt201", "climateup2adapt6001")

scenario_labels_to_plot <- sort(filter(scenarios, scenario %in% c(scenario_to_plot))$Climate_AdapOpt)

SWSDLName_to_plot <- c("Macquarieâ€“Castlereagh", "Lachlan", "Namoi")

catch_demo <- sdl_units %>% 
  dplyr::filter(SWSDLName %in% SWSDLName_to_plot)
```

```{r}
#| echo: false
#| include: false

## For mapping gauges

#do i have to run the gauge getter everytime?
#GET R VERSION

# demo_gauges <- st_intersection(bom_basin_gauges, catch_demo)
# gaugenums <- demo_gauges$gauge
# 
# pdi <- import("py_ewr.data_inputs")
# ewrs_in_pyewr <- pdi$get_EWR_table() 
# names(ewrs_in_pyewr) <- c('ewrs', 'badewrs')
# 
# ewrgauges <- ewrs_in_pyewr$ewr$Gauge
# ewr_demo_gauges <- gaugenums[gaugenums %in% ewrgauges]
# 


# # 
# # gg <- import('mdba_gauge_getter')
# # demo_levs <- gg$gauge_pull(ewr_demo_gauges, start_time_user = starttime, end_time_user = endtime)
# # demo_ids <- unique(demo_levs$SITEID)
# # length(demo_ids)
# 
# demo_ids <- ewr_demo_gauges #so i dont have to run gauge getter
# 
# demo_geo = bom_basin_gauges %>% dplyr::filter(gauge %in% demo_ids)
```

```{r}
#| echo: false
#| include: false

## Standard scenario appearance

# not sure about this method of odering scenarios, isnt great when there are two scenario factors
# colours max out as welll

scene_pal <- make_pal(unique(scenehydros$scenario),                       
                      palette = "viridis::mako", #'ggsci::nrc_npg', 
                      refvals = 'base', refcols = 'black')

gauge_pal <- make_pal(unique(scenehydros$gauge),                       
                      palette = "viridis::turbo") #'ggsci::nrc_npg')

Climate_pal <- make_pal(levels = unique(scenehydros$Climate),                       
               palette = "dichromat::BluetoOrange_10")

AdapOpt_pal <- make_pal(levels = unique(scenehydros$AdapOpt),                       
               palette = "dichromat::BluetoOrange_10")

SDL_pal <- make_pal(unique(agged_data$sdl_units$SWSDLName),                       
                      palette = "palettesForR::Plasma") #'ggsci::nrc_npg')

SWSDLID_pal <- make_pal(unique(agged_data$sdl_units$SWSDLID),                       
                      palette = "palettesForR::Plasma") #'ggsci::nrc_npg')
                      
SWSDLName_pal <- make_pal(unique(agged_data$sdl_units$SWSDLName),                       
                      palette = "palettesForR::Plasma") #'ggsci::nrc_npg')

env_pals = list(EF = 'grDevices::Purp',
                NF = 'grDevices::Mint',
                NV = 'grDevices::Burg',
                OS = 'grDevices::Blues',
                WB = 'grDevices::Peach')

ewr_achieved_pal <- list('scico::berlin')

scene_pal
gauge_pal
Climate_pal
AdapOpt_pal
SDL_pal
SWSDLID_pal
env_pals

```

```{r}
#| echo: false
#| include: false

## Plotting hydrographs

#Fig 2
# Currently making manually
# need to use facet grid instead of facet wrap

hydro_plot <- scenehydros |>
    dplyr::filter(scenario %in% c(scenario_to_plot) & gauge %in% gauges_to_plot) |>
    #dplyr::filter(scenario %in% c(scenario_to_plot, "MAX") & gauge %in% gauges_to_plot) |>
    ggplot2::ggplot(ggplot2::aes(x = Date, y = flow/1000+1, color = gauge)) +
    ggplot2::geom_line() +
    ggplot2::facet_grid(Climate~AdapOpt, scales = 'fixed') +
    ggplot2::labs(y = paste0("Flow (GL/day)"), color = 'Gauge ID:') +
    ggplot2::scale_y_continuous(#trans = 'log10',
                                sec.axis = sec_axis(~ . , name = "Climate scenarios", breaks = NULL, labels = NULL)) +
    ggplot2::scale_x_date(sec.axis = sec_axis(~ . , name = "Adaptation options", breaks = NULL, labels = NULL)) +
    ggplot2::scale_color_manual(values = gauge_pal) +
    theme_werp_toolkit(legend.position = "bottom")+
      guides(colour=guide_legend(nrow=2,byrow=TRUE))


saveRDS(hydro_plot, file = file.path(comp_results, "hydro_plot.Rdata"))
hydro_plot

```

```{r}
#interested to see where threshold water levels are on hydrograph
NSWEWR_gauge <- filter(NSWEWR, Gauge %in% gauges_to_plot) |>
  tidyr::separate(col = Code, into = c("Code", "Timing")) |>
  rename(gauge = Gauge) |>
  group_by(gauge) %>%
  distinct(Code, .keep_all = TRUE) |>
  mutate(FlowThresholdMin = as.numeric(FlowThresholdMin)) |>
  arrange(FlowThresholdMin) %>%
  mutate(Date = seq(from = max(scenehydros$Date), 
                    to = min(scenehydros$Date), 
                    length.out = n())) %>%
  ungroup()

hydro_plot_EWRs <- scenehydros |>
    dplyr::filter(scenario %in% c(scenario_to_plot[4]) & gauge %in% gauges_to_plot) |>
    ggplot2::ggplot(ggplot2::aes(x = Date, y = flow/1000+1)) +
    ggplot2::geom_hline(data = NSWEWR_gauge, mapping = aes(yintercept = FlowThresholdMin/1000+1),colour = "red")+ #
    ggplot2::geom_line() +
    ggplot2::facet_grid(gauge ~ . , scales = 'free') +
    ggplot2::labs(y = paste0("Flow (GL/day +1)")) +
    theme_werp_toolkit(legend.position = "bottom")+
      guides(colour=guide_legend(nrow=2,byrow=TRUE))+
    ggplot2::geom_label(data = NSWEWR_gauge, mapping = aes(x = Date, y = FlowThresholdMin/1000+1, label = Code), size = 3, colour = "black") +
  ggplot2::scale_y_continuous(trans = 'log10',
                              sec.axis = sec_axis(~ . , name = "Gauge ID", breaks = NULL, labels = NULL))

saveRDS(hydro_plot_EWRs, file = file.path(comp_results, "hydro_plot_EWRs.Rdata"))
hydro_plot_EWRs


write.csv(NSWEWR_gauge, file = file.path(comp_results, "EWRs_2_gauges.csv"))
```

```{r}
#| echo: false
#| include: false

## Baselining

# Fig 3
# Currently making manually
#but use 1) base_lev = 'base',
#and 2) comp_fun = difference,
#when plot_hydrographs id fixed for facetting

dif_plot <- scenehydros |>
    dplyr::filter(scenario %in% scenario_to_plot & gauge %in% gauges_to_plot) |>
    ggplot2::ggplot(ggplot2::aes(x = Date, y = difference_flow/1000, color = gauge)) +
    ggplot2::geom_line() +
    ggplot2::facet_grid(Climate~AdapOpt, scales = 'fixed') +
    ggplot2::labs(y = paste0("Flow (GL/day)"), color = 'Gauge ID') +
    ggplot2::scale_y_continuous(trans = 'identity',
                                sec.axis = sec_axis(~ . , name = "Climate   scenarios", breaks = NULL, labels = NULL)) +
    ggplot2::scale_x_date(sec.axis = sec_axis(~ . , name = "Adaptation options", breaks = NULL, labels = NULL)) +
    ggplot2::scale_color_manual(values = gauge_pal)  +
    theme_werp_toolkit(legend.position = "bottom")+
    guides(colour=guide_legend(nrow=2,byrow=TRUE))

rel_plot <- scenehydros |>
    dplyr::filter(scenario %in% scenario_to_plot & gauge %in% gauges_to_plot) |>
    ggplot2::ggplot(ggplot2::aes(x = Date, y = relative_flow/1000, color = gauge)) +
    ggplot2::geom_line() +
    ggplot2::facet_grid(Climate~AdapOpt, scales = 'fixed') +
    ggplot2::labs(y = paste0("Flow (GL/day)"), color = 'Gauge ID') +
    ggplot2::scale_y_continuous(trans = 'identity',
                                sec.axis = sec_axis(~ . , name = "Climate   scenarios", breaks = NULL, labels = NULL)) +
    ggplot2::scale_x_date(sec.axis = sec_axis(~ . , name = "Adaptation options", breaks = NULL, labels = NULL)) +
    ggplot2::scale_color_manual(values = gauge_pal)  +
    theme_werp_toolkit(legend.position = "bottom")+
    guides(colour=guide_legend(nrow=2,byrow=TRUE))


saveRDS(dif_plot, file = file.path(comp_results, "hydro_dif_plot.Rdata"))
saveRDS(rel_plot, file = file.path(comp_results, "hydro_rel_plot.Rdata"))
dif_plot
```

```{r}
#get Aus geometry
library(ozmaps)
g <- ozmap()
Australia <- g$geometry[-9]

```

```{r}
#| echo: false
#| include: false

## Plotting study system

# Fig 1
#CAN WE ADD inset of australia?
# where do i find R version of gauge getter?
Aus_plot <- (ggplot() + 
geom_sf(data = Australia, fill = 'black', colour = 'black') +              
geom_sf(data = basin, fill = 'azure')) +
theme_werp_toolkit(axis.ticks = element_blank(), 
                         axis.text=element_blank(),
                         legend.position="bottom") +
guides(fill=guide_legend(nrow=3,byrow=TRUE)) 
  

system_plot <- (ggplot() + 
#geom_sf(data = Australia) +              
geom_sf(data = basin, fill = 'azure') +
geom_sf(data = catch_demo, mapping = aes(fill = SWSDLName)) +
scale_fill_manual(values = SWSDLName_pal, name = "Planning units:") + 
geom_sf(data = filter(bom_basin_gauges, gauge %in% unique(scenehydros$gauge)), color = 'black')) +
theme_werp_toolkit(axis.ticks = element_blank(), 
                         axis.text=element_blank(),
                         legend.position="bottom") +
guides(fill=guide_legend(nrow=3,byrow=TRUE))
#need to cut back more gauges i think


system_plots <- system_plot + inset_element(Aus_plot, 0.01, 0.6, 0.4, 1)
system_plots
saveRDS(system_plots, file = file.path(comp_results, "system_plot.Rdata"))

```

```{r}
#| echo: false
#| include: false

## Comparer

# make the super long names shorter but less useful.
basin_to_plot <- agged_data$mdb %>% 
  dplyr::filter(!is.na(Objective)) %>% 
  dplyr::mutate(Objective = stringr::str_trunc(Objective, 15)) %>% 
  dplyr::group_by(scenario, Objective) %>% 
  dplyr::mutate(id = as.character(row_number())) %>% 
  dplyr::ungroup() %>% 
  dplyr::mutate(Objective = stringr::str_c(Objective, '_', id)) %>% 
  dplyr::select(-id)

# Create a grouping variable
obj_sdl_to_plot <- agged_data$sdl_units |>
  dplyr::mutate(env_group = stringr::str_extract(env_obj, '^[A-Z]+')) |>
  dplyr::filter(!is.na(env_group)) |>
  dplyr::arrange(env_group, env_obj) |>
  dplyr::filter(SWSDLName %in% c("Macquarieâ€“Castlereagh", "Lachlan", "Namoi")) #|>
  #dplyr::filter(scenario %in% scenario_to_plot)

#need to join deltas
basin_to_plot <- left_join(basin_to_plot, scenarios, by = join_by(scenario))
obj_sdl_to_plot <- left_join(obj_sdl_to_plot, scenarios, by = join_by(scenario))

# To make relative to MAX scenario
MAX_obj_sdl_to_plot <- obj_sdl_to_plot |> 
  dplyr::filter(scenario == "MAX") |>
  dplyr::mutate(MAX_ewr_achieved = ewr_achieved) |>
  as_tibble() |>
  select("SWSDLName", "SWSDLID", "env_obj", "MAX_ewr_achieved")

obj_sdl_to_plot <- left_join(obj_sdl_to_plot, MAX_obj_sdl_to_plot, 
                  by = join_by(SWSDLName, SWSDLID, env_obj)) 

env_group_sdl_to_plot <- obj_sdl_to_plot %>% 
  #dplyr::filter(scenario %in% c(scenario_to_plot)) |>
  dplyr::group_by(SWSDLName, SWSDLID, scenario, Climate_AdapOpt, Climate, AdapOpt, env_group, flow_multiplier, flow_addition, delta_diff)  |>
  dplyr::summarise(sum_ewr_achieved = sum(ewr_achieved, na.rm = TRUE),
                   sum_MAX_ewr_achieved = sum(MAX_ewr_achieved, na.rm = TRUE)) |> 
                                                #mean? another level of aggregation 
  dplyr::mutate(proportion_ewr_achieved = sum_ewr_achieved/sum_MAX_ewr_achieved) |>
  dplyr::ungroup()

BASE_env_group_sdl_to_plot <- env_group_sdl_to_plot |>
  filter(scenario == "climatebaseadapt0") |>
  as_tibble() |>
  select("SWSDLName", "SWSDLID", "env_group", "proportion_ewr_achieved") |>
  rename(BASE_proportion_ewr_achieved = proportion_ewr_achieved)

env_group_sdl_to_plot <- left_join(env_group_sdl_to_plot, BASE_env_group_sdl_to_plot, by = join_by(SWSDLName, SWSDLID, env_group)) |>
  mutate(proportion_ewr_achieved_relative_to_BASE = proportion_ewr_achieved/ BASE_proportion_ewr_achieved)

env_theme_sdl_to_plot <- env_group_sdl_to_plot |>
  dplyr::group_by(SWSDLName, SWSDLID, scenario, Climate_AdapOpt, Climate, AdapOpt, flow_multiplier, flow_addition)  |>
  dplyr::summarise(proportion_ewr_achieved = mean(proportion_ewr_achieved, na.rm = TRUE)) 

env_theme_catchment_to_plot <- env_theme_sdl_to_plot |>
  dplyr::group_by(scenario, Climate_AdapOpt, Climate, AdapOpt, flow_multiplier, flow_addition)  |>
  dplyr::summarise(proportion_ewr_achieved = mean(proportion_ewr_achieved, na.rm = TRUE))

```

```{r}
Failed_EWRs_MAX <- agged_data$ewr_code |>
  filter(scenario == "MAX") |>
  filter(ewr_achieved < 1) #|>
  #distinct(ewr_code)

#saveRDS(Failed_EWRs_MAX, "C:/Users/georgiad/Documents/WERP_toolkit_demo/more_scenarios_manual_save/Failed_EWRs_MAX.rds")

# "BK" and "CF" not in LTWPs for M-C
# SF1 and SF2 are in the LTWPs for M-C:
# SF1 = > 200 ML/d, Anytime (ideally Octâ€“Apr), 10 days, Annually (10 years in 10) (100% of years)
# SF 2 = 200â€“1,000 ML/d, Sepâ€“Apr (Sepâ€“Dec for Murray cod spawning), 14 days, 5â€“10 years in 10 (75% of years)

# BK1 - NAmoi
# > 3500 ML/d, Oct to Apr, 4 days minimum* (ideally > 10 days3), 5 years in 10 (50% LTA)

# CF1 - NAMOI
# 0 ML/d, Jan to June, Typically CtF events should be around 6 days. Should occur in no more than 35% of years, CtF should not persist for longer than 29 days

# maybe we don't have 10 years of data?
# unique(temp$ewr_code)
# [1] "BK1" "CF1" "SF2" "SF1"

# maunally fix now, get Lara to fix in EWR tool
# maybe NA with less than 10 years data
# range(scenehydros$Date)
# "2010-01-01" "2021-12-31"

#still not working wiht 12 years????

#Manual fix has to be before aggregator. 

#temp <- agged_data$ewr_code |>
#  filter(ewr_code == "BK1") #|>
#  #filter(ewr_achieved < 1) #|>  

#notes for Lara
#SF1 - Gauges 421001, 421004, 421011, 421012, target frequency = 1000
#SF2 - Target frequency seems correct, everything else 0.
#BK1 - Gauge 412039, Target frequency seems correct, everything else 0.

#where ewr is % of years that % is the target frequency - but that doesnt match up wiht frequency.
Failed_EWRs_MAX
```

```{r}
#| echo: false
#| include: false
#| message: false

# Notes on plot_outcomes()
#takes a long time to fail when it cannot find a thing (e.g. sceneorder). maybe it could run a check before it does anything else?

# Currently making manually
# add facets for climate and adaptopts?
# adds space

# how do i change colours to be 'ewrachieved?
 #ANSWER: colorgroups = NULL, colorset = 'ewr_achieved', pal_list = list('scico::berlin'),

#TOOLKIT:
#This doesnt quite work/???
# Fig_5_PanelAa <- env_theme_sdl_to_plot %>% 
# plot_outcomes(x_col = "SWSDLID",
#               y_col = 'ewr_achieved',
#               facet_col =  "Climate + AdapOpt",  #THIS DOESNT WORK
#               facet_row = '.',
#               colorset = 'SWSDLID',
#               pal_list = SWSDLID_pal,
#               #sceneorder = sceneorder,
#               position = 'dodge' #position = 'stack' #
#               )+
#       ggplot2::scale_fill_manual(values = SWSDLID_pal)#+
#               #facet_grid(. ~ Climate + AdapOpt) #THIS DOESNT WORK


#MANUAL:
Fig_5_PanelA <- filter(env_theme_sdl_to_plot, scenario %in% scenario_to_plot) |>
      ggplot2::ggplot(ggplot2::aes(x = SWSDLID, y = proportion_ewr_achieved,
                                   fill = SWSDLName)) +
      ggplot2::geom_col(position = 'stack') +
      facet_grid(. ~ Climate_AdapOpt) +
      #ggplot2::labs(y = paste0(y_lab, prepped$ylab_append)) +
      #ggplot2::scale_y_continuous(trans = 'identity') +
      ggplot2::scale_fill_manual(values = SWSDLName_pal, name = "Planning units:") +
      #ggplot2::scale_x_discrete(guide = ggplot2::guide_axis(angle = 45)) +
      ggplot2::labs(y = "Proportion EWR achieved") +
  
      ggplot2::scale_color_identity() +
      theme_werp_toolkit(axis.ticks.x = element_blank(), 
                         axis.text.x=element_blank(),
                         #axis.title.x = element_blank(),
                         legend.position="bottom")+
      guides(fill=guide_legend(nrow=3,byrow=TRUE)) + 
      scale_x_discrete(position = "top", name = "Climate & Adaptation Option Scenario")
  
  #using proportion of max gets around needing to add it to plots - do we still want to be able to do that?
  # #ADD IN MAX:  
  # ggplot2::geom_col(data = filter(Fig5_data, scenario == "MAX"), aes(x = SWSDLID, y = ewr_achieved,
  #                              fill = SWSDLName), position = 'stack', colour = "black", fill = NA) 

saveRDS(Fig_5_PanelA, file = file.path(comp_results, "Fig_5_PanelA.Rdata"))
Fig_5_PanelA

```

```{r}
#attemption to extract info from figure:
names(Fig_5_PanelA)
temp <-Fig_5_PanelA$data

Fig_5_PanelA$layers

Fig_5_PanelA$scales

Fig_5_PanelA$mapping

#Fig_5_PanelA$theme

#Fig_5_PanelA$coordinates

#Fig_5_PanelA$facet

#Fig_5_PanelA$plot_env

Fig_5_PanelA$labels

#Fig_5_PanelA$guides
```

```{r}
#| echo: false
#| include: false

# Fig 5 - panel B
Fig_5_PanelB <- env_theme_sdl_to_plot |>
    #dplyr::filter(env_group == 'WB') |> # Need to reduce dimensionality
    plot_outcomes(y_col = 'proportion_ewr_achieved',
                  y_lab = 'Proportion EWR\nachieved',
                          x_col = 'map',
                          colorgroups = NULL,
                          colorset = 'proportion_ewr_achieved',
                          pal_list = list('scico::berlin'),
                          facet_col = 'AdapOpt',
                          facet_row = 'Climate',
                          scene_pal = scene_pal,
                          #sceneorder = sceneorder,
                          scenariofilter = scenario_to_plot,
                          underlay_list = list(underlay = basin, 
                                               underlay_pal = 'azure')) +
    ggplot2::scale_y_continuous(trans = 'identity', sec.axis = sec_axis(~ . , name = "Climate scenario", breaks = NULL, labels = NULL)) +
    ggplot2::scale_x_continuous(sec.axis = sec_axis(~ . , name = "Adaptation option", breaks = NULL, labels = NULL))+
      theme_werp_toolkit(axis.ticks = element_blank(), 
                         axis.text=element_blank(),
                         legend.position="bottom")+
    paletteer::scale_fill_paletteer_c(palette = 'scico::berlin', limits = c(0,1), name = 'Proportion EWR achieved')

saveRDS(Fig_5_PanelB, file = file.path(comp_results, "Fig_5_PanelB.Rdata"))
Fig_5_PanelB 
```

```{r}
#aggregation table
Fig_5_table <- data.frame(Scale = c("Scenario", rep("", times = 1), 
                                    "Space", rep("", times = 2), 
                                     "Theme", rep("", times = 4)),
                                 Things = c("Climate", "Adaptation option", 
                                          "Gauges", "Planning units", "Catchment", 
                                          "EWR timing (wet/dry year)", "EWR", 
                                          "Environmental objectives", "Environmental targets", 
                                          "Environmental total"),
                                 Fig5a = c("[Vertical facets]", "[Vertical facets]",
                                           "ArithmeticMean aggregation", "[x-axis; Colour]", NA,
                                           "CompensatingFactor aggregation","ArithmeticMean aggregation",
                                           "ArithmeticMean aggregation","Proportion of MAX aggregation", 
                                           "ArithmeticMean aggregation [y-axis]"))

Fig_5_table$Fig5b <- c("[Horizontal facets]", "[Vertical facets]",
                              "ArithmeticMean aggregation", "[Polygons]", NA,
                              "CompensatingFactor aggregation","ArithmeticMean aggregation","ArithmeticMean aggregation","Proportion of MAX aggregation", "ArithmeticMean aggregation [colour]")

saveRDS(Fig_5_table, file = file.path(comp_results, "Fig_5_table.Rdata"))
```

```{r}
Fig_5 <- Fig_5_PanelA + Fig_5_PanelB + plot_annotation(tag_levels = 'a') #+ plot_layout(guides = "collect") & theme(legend.position = 'bottom')

saveRDS(Fig_5, file = file.path(comp_results, "Fig_5.Rdata"))
Fig_5
```

```{r}
#| echo: false
#| include: false
#| message: false

#would like to change to Climate_AdapOpt on x axis 
#cant control colours when i change the x axis and some bars dissapear????
#NEED SOME WAY of knowing whether env objectives are not relevant or are not met when they donâ€™t exist.

# Fig6_data <- obj_sdl_to_plot %>% 
#   dplyr::filter(scenario %in% scenario_to_plot) |>
#   dplyr::group_by(SWSDLName, SWSDLID, scenario, Climate_AdapOpt, Climate, AdapOpt, env_group) %>% 
#   dplyr::summarise(ewr_achieved = sum(ewr_achieved, na.rm = TRUE)) %>% 
#   dplyr::ungroup() +
#   dplyr::complete(SWSDLName, env_group)

# Fig 6
Fig_6 <- obj_sdl_to_plot |>
  dplyr::filter(scenario %in% c(scenario_to_plot, "MAX")) |>
  #dplyr::mutate(scenario = Climate_AdapOpt) |> #this doesnt work
  plot_outcomes(#x_col = "Climate_AdapOpt",
                y_col = 'ewr_achieved',
                y_lab = "EWR achieved",
                x_lab = "Climate & Adaptation Option Scenario",
                colorgroups = 'env_group',
                colorset = 'env_obj',
                pal_list = env_pals,
                color_lab = "Envionmental objectives",
                #pal_list = list('scico::berlin'),
                facet_col = 'SWSDLName',
                facet_row = 'env_group',
                sceneorder = sceneorder[sceneorder %in% c(scenario_to_plot, "MAX")] #+
                #scenariofilter = scenario_to_plot
                )+
  ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  scale_y_continuous(n.breaks = 3)+
  scale_x_discrete(labels= c(scenario_labels_to_plot, "MAX"))

# ADD IN MAX: #BOX ON TOP AT END
Fig_6Max <- Fig_6 + 
ggplot2::geom_col(data = filter(obj_sdl_to_plot, scenario %in% c("MAX")), 
                                      aes(x = scenario, y = ewr_achieved),
                                      position = 'stack', colour = "black", fill = NA) 

saveRDS(Fig_6Max, file = file.path(comp_results, "Fig_6.Rdata"))
Fig_6Max

#stealing legend for Fig 8
leg <- ggpubr::get_legend(Fig_6Max)
Fig_6_leg <- ggpubr::as_ggplot(leg)


temp <-Fig_6$data |>
  group_by(SWSDLName,scenario, env_group)|>
  summarise(sum(ewr_achieved))

```

```{r}
#aggregation table
Fig_6_table <- data.frame(Scale = c("Scenario", rep("", times = 1), 
                                    "Space", rep("", times = 2), 
                                     "Theme", rep("", times = 4)),
                                 Things = c("Climate", "Adaptation option", 
                                          "Gauges", "Planning units", "Catchment", 
                                          "EWR timing (wet/dry year)", "EWR", 
                                          "Environmental objectives", "Environmental targets", 
                                          "Environmental total"),
                                 Fig6 = c("[x-axis]", "[x-axis]",
                                           "ArithmeticMean aggregation", "[vertical facets]", NA,
                                           "CompensatingFactor aggregation","ArithmeticMean aggregation",
                                           "ArithmeticMean aggregation [y-axis; color]",
                                           "Proportion of MAX aggregation [horizontal facets; color]", 
                                           NA))

saveRDS(Fig_6_table, file = file.path(comp_results, "Fig_6_table.Rdata"))
```

```{r}
#| echo: false
#| include: false

# Fig_7a<- obj_sdl_to_plot |>
#     dplyr::filter(scenario %in% scenario_to_plot) |>
#     dplyr::filter(env_group == 'WB') |> # Need to reduce dimensionality
#     plot_outcomes(#x_col = "Climate_AdapOpt",
#                   y_col = 'ewr_achieved',
#                   y_lab = 'Proportion EWR achieved',
#                           x_col = 'map',
#                           colorgroups = NULL,
#                           colorset = 'ewr_achieved',
#                           pal_list = list('scico::berlin'),
#                           facet_col = 'env_obj',
#                           facet_row = 'scenario',
#                           scene_pal = scene_pal,
#                           #sceneorder = sceneorder,
#                           scenariofilter = scenario_to_plot,
#                           underlay_list = list(underlay = basin, 
#                                                underlay_pal = 'azure')) +
#     ggplot2::scale_y_continuous(sec.axis = sec_axis(~ . , name = "Climate & Apaptation Option Scenario", breaks = NULL, labels = NULL)) +
#     ggplot2::scale_x_continuous(sec.axis = sec_axis(~ . , name = "Environmental objective", breaks = NULL, labels = NULL))+
#     theme_werp_toolkit(axis.ticks = element_blank(), 
#                          axis.text=element_blank(),
#                           legend.position="bottom") +
#     paletteer::scale_fill_paletteer_c(palette = 'scico::berlin', limits = c(0,1), name = 'Proportion EWR achieved') +
#   # scale_x_discrete(labels= scenario_labels_to_plot)


  #making manually:  
Fig_7a <- obj_sdl_to_plot |>
    dplyr::filter(scenario %in% scenario_to_plot) |>
    dplyr::filter(env_group == 'WB') |> # Need to reduce dimensionality
    ggplot(aes(fill = ewr_achieved)) + 
    facet_grid(Climate_AdapOpt~env_obj)+
    geom_sf(data = basin, fill = 'azure') + #basin
    geom_sf()+ #planning units
    paletteer::scale_fill_paletteer_c(palette = 'scico::berlin', limits = c(0,1), name = 'Proportion EWR achieved') +
    #geom_sf(data = dplyr::filter(agged_data$env_obj, env_obj == 'WB1' & scenario %in% scenario_to_plot[1]), aes(fill = ewr_achieved), shape = 21)+ #gauges
    theme_werp_toolkit(axis.ticks = element_blank(), 
                         axis.text=element_blank(),
                         legend.position="bottom")+
    ggplot2::scale_y_continuous(sec.axis = sec_axis(~ . , name = "Climate & Apaptation Option Scenario", breaks = NULL, labels = NULL)) +
    ggplot2::scale_x_continuous(sec.axis = sec_axis(~ . , name = "Environmental objective", breaks = NULL, labels = NULL))
  
  
saveRDS(Fig_7a, file = file.path(comp_results, "Fig_7a.Rdata"))
Fig_7a

Fig_7a_noleg <- Fig_7a +
  theme(legend.position = "none")


```

```{r}
#| echo: false
#| include: false
# 
# Fig_7b<- obj_sdl_to_plot |>
#     dplyr::filter(scenario %in% scenario_to_plot[1]) |>
#     dplyr::filter(env_obj == 'WB1') |> # Need to reduce dimensionality
#     plot_outcomes(#x_col = "Climate_AdapOpt",
#                   y_col = 'ewr_achieved',
#                   y_lab = 'Proportion EWR achieved',
#                           x_col = 'map',
#                           colorgroups = NULL,
#                           colorset = 'ewr_achieved',
#                           pal_list = list('scico::berlin'),
#                           facet_col = 'env_obj',
#                           facet_row = 'scenario',
#                           scene_pal = scene_pal,
#                           #sceneorder = sceneorder,
#                           scenariofilter = scenario_to_plot,
#                           underlay_list = list(underlay = basin, 
#                                                underlay_pal = 'azure'),
#                           overlay_list = list(#list(overlay = 'sdl_units', overlay_pal = 'black'),
#                                               list(overlay = dplyr::filter(agged_data$env_obj, env_obj == 'WB1' & scenario %in% scenario_to_plot[1]),
#                                                     overlay_pal = 'scico::berlin',
#                                                     overlay_ycol = 'ewr_achieved',
#                                                    overlay_ylab = 'Proportion EWR achieved')))+
#     ggplot2::scale_y_continuous(sec.axis = sec_axis(~ . , name = "Climate & Apaptation Option Scenario", breaks = NULL, labels = NULL)) +
#     ggplot2::scale_x_continuous(sec.axis = sec_axis(~ . , name = "Environmental objective", breaks = NULL, labels = NULL))+
#     theme_werp_toolkit(axis.ticks = element_blank(), 
#                          axis.text=element_blank(),
#                           legend.position="none")# +
#   ggplot2::scale_colour_gradientn(colours = list('scico::berlin'), values = c(0,1))#+#+
  # scale_x_discrete(labels= scenario_labels_to_plot)

#making manually:  Cannot currently change scenario labels with plot_outcomes()
Fig_7b <- obj_sdl_to_plot |>
    dplyr::filter(scenario %in% scenario_to_plot[1]) |>
    dplyr::filter(env_obj == 'WB1') |> # Need to reduce dimensionality
    ggplot(aes(fill = ewr_achieved)) + 
    facet_grid(Climate_AdapOpt~env_obj)+
    geom_sf(data = basin, fill = 'azure') + #basin
    geom_sf()+ #planning units
    paletteer::scale_fill_paletteer_c(palette = 'scico::berlin', limits = c(0,1), name = 'Proportion EWR achieved') +
    geom_sf(data = dplyr::filter(agged_data$env_obj, env_obj == 'WB1' & scenario %in% scenario_to_plot[1]), aes(fill = ewr_achieved), shape = 21)+ #gauges
    theme_werp_toolkit(axis.ticks = element_blank(), 
                         axis.text=element_blank(),
                         legend.position="bottom")+
    guides(fill = guide_colourbar(title.position="top"), title.hjust = 0.5)+
    ggplot2::scale_y_continuous(sec.axis = sec_axis(~ . , name = "Climate & Apaptation Option Scenario", breaks = NULL, labels = NULL)) +
    ggplot2::scale_x_continuous(sec.axis = sec_axis(~ . , name = "Environmental objective", breaks = NULL, labels = NULL))
  

saveRDS(Fig_7b, file = file.path(comp_results, "Fig_7b.Rdata"))
Fig_7b

Fig_7 <- Fig_7a_noleg + wrap_elements(full = Fig_7b) + plot_layout(widths = c(2,1))  + plot_annotation( tag_levels = 'a') 

saveRDS(Fig_7, file = file.path(comp_results, "Fig_7.Rdata"))

Fig_7
```

```{r}
#aggregation table
Fig_7_table <- data.frame(Scale = c("Scenario", rep("", times = 1), 
                                    "Space", rep("", times = 2), 
                                     "Theme", rep("", times = 4)),
                                 Things = c("Climate", "Adaptation option", 
                                          "Gauges", "Planning units", "Catchment", 
                                          "EWR timing (wet/dry year)", "EWR", 
                                          "Environmental objectives", "Environmental targets", 
                                          "Environmental total"),
                                 Fig7a = c("[horizontal facets]", "[horizontal facets]",
                                           "ArithmeticMean aggregation", "[polygons]", NA,
                                           "CompensatingFactor aggregation","ArithmeticMean aggregation",
                                           "ArithmeticMean aggregation [vertical facets; color]",
                                           NA, NA),
                                Fig7b = c("[subset to A]", "[subset to 1]",
                                           "ArithmeticMean aggregation [points]", "[polygons]", NA,
                                           "CompensatingFactor aggregation","ArithmeticMean aggregation [point color]",
                                           "ArithmeticMean aggregation [subset to WB1; ploygon color]",
                                           NA, NA)) 

saveRDS(Fig_7_table, file = file.path(comp_results, "Fig_7_table.Rdata"))
```

```{r}
#| echo: false
#| include: false

# Fig 8
 sdl_line <- obj_sdl_to_plot |>
    dplyr::filter(scenario %in% scenario_to_plot) |>
    dplyr::filter(env_group == 'NF') |> # Need to reduce dimensionality
    plot_outcomes(y_col = 'ewr_achieved',
                  y_lab = "Proportion EWR achieved",
                  x_col = 'delta_diff',
                  x_lab = "Change in flow (total difference)",
                  colorgroups = 'env_group',
                  colorset = 'env_obj',
                  pal_list = env_pals,
                  color_lab = "Envionmental objectives",
                          facet_row = 'SWSDLName',
                          facet_col = '.',
                          scene_pal = scene_pal,
                          #sceneorder = sceneorder,
                  scenariofilter = scenario_to_plot) +
                  geom_vline(data = filter(delta_table, scenario  %in% scenario_to_plot), 
                              mapping = aes(xintercept = delta_diff))#+
      #scale_fill_discrete(breaks=unique(obj_sdl_to_plot$env_obj)) + #to order the legend colours
      #theme_werp_toolkit(legend.position = "none")
                         
 scenario_deltas <- ggplot(data = filter(scenarios, scenario  %in% scenario_to_plot), 
                           mapping = aes(x = delta_diff, y = 1)) +
                    geom_vline(xintercept = filter(scenarios, scenario  %in% scenario_to_plot)$delta_diff) +
                    ggrepel::geom_text_repel(label = filter(scenarios, scenario  %in% scenario_to_plot)$Climate_AdapOpt, size = 3, angle = 90,
                                             direction='x')+ 
                    theme_werp_toolkit(legend.position = "none", axis.title=element_blank(),
                    axis.text=element_blank(), axis.ticks=element_blank())
   #ggtext::geom_richtext

 
 
 Fig_8 <- scenario_deltas + sdl_line + plot_layout(ncol = 1, heights = c(1,15)) + theme(legend.position = "right")
 saveRDS(Fig_8, file = file.path(comp_results, "Fig_8.Rdata"))
 Fig_8

 #use rlative instead of difference
 # NOTES: Cannot work out how to order legend - doesnt matter now that subset to NF but still a problem
```

```{r}
#aggregation table
Fig_8_table <- data.frame(Scale = c("Scenario", rep("", times = 1), 
                                    "Space", rep("", times = 2), 
                                     "Theme", rep("", times = 4)),
                                 Things = c("Climate", "Adaptation option", 
                                          "Gauges", "Planning units", "Catchment", 
                                          "EWR timing (wet/dry year)", "EWR", 
                                          "Environmental objectives", "Environmental targets", 
                                          "Environmental total"),
                                 Fig8 = c("Difference from base [x-axis]", "Difference from base [x-axis]",
                                           "ArithmeticMean aggregation", "[horizontal facets]", NA,
                                           "CompensatingFactor aggregation","ArithmeticMean aggregation",
                                           "ArithmeticMean aggregation [y-axis; color]",
                                           "[color]", 
                                           NA))

saveRDS(Fig_8_table, file = file.path(comp_results, "Fig_8_table.Rdata"))
```

```{r}
#| echo: false
#| include: false

#EDITS: making this manually. cant work out how to fit lines to adaptation option - i think smoothed fits for all environmental objectives isnt quite right because some targets have more than others so doing it this way

# sdl_fit_sdl <- obj_sdl_to_plot |>
#   plot_outcomes(y_col = 'ewr_achieved',
#                 x_col = 'delta_diff',
#                 y_lab = 'Proportion EWR achieved',
#                 x_lab = 'Change in flow (difference)',
#                 transx = 'log10',
#                 transy = 'log10',
#                 color_lab = 'SDL unit',
#                 colorset = 'SWSDLName',
#                 pal_list = list("ggsci::default_jama"),
#                 facet_wrapper = 'env_group',
#                 scene_pal = scene_pal,
#                 sceneorder = sceneorder[sceneorder %in% c(scenario_to_plot)],
#                 base_lev = "climatebaseadapt0",
#                 comp_fun = 'relative',
#                 add_eps = min(obj_sdl_to_plot$ewr_achieved[obj_sdl_to_plot$ewr_achieved > 0], 
#                               na.rm = TRUE)/2,
#                 group_cols = c('env_obj', 'polyID'),
#                 smooth = TRUE)
# 
# suppressWarnings(print(sdl_fit_sdl))

# Fig 9
# copied straight from Galens book and
# Getting errors:
# Caused by error in `across()`:
# ! Can't compute column `relative_ewr_achieved`.
# Caused by error in `.data[["ref_ewr_achieved"]]`:
# ! Column `ref_ewr_achieved` not found in `.data`.

# sdl_lm_groups_3 <- env_group_sdl_to_plot |>
#     plot_outcomes(y_col = 'proportion_ewr_achieved',
#                           x_col = 'delta_diff',
#                           y_lab = 'Proportion EWR achieved',
#                           x_lab = 'Change in flow (difference)',
#                           transx = 'log10',
#                           color_lab = 'Environmental grouping',
#                           colorgroups = NULL,
#                           colorset = 'env_group',
#                           point_group = 'env_group',
#                           pal_list = list('scico::berlin'),
#                           facet_row = 'env_group',
#                           facet_col = 'SWSDLName',
#                           scene_pal = scene_pal,
#                           sceneorder = sceneorder[sceneorder %in% c(scenario_to_plot)],
#                           scenariofilter = scenario_to_plot,
#                           base_lev = "climatebaseadapt0",
#                   add_eps = 0.01,
#                           comp_fun = 'relative',
#                           group_cols = c('AdapOpt'),
#                           smooth = TRUE,
#                   #smooth_method = "lm",
#                   smooth_se = FALSE)
# # group_cols - not in help

#MANUAL:
sdl_lm_groups <- filter(env_group_sdl_to_plot, scenario != "MAX") |>
      ggplot2::ggplot(ggplot2::aes(x = flow_multiplier, y = proportion_ewr_achieved_relative_to_BASE+1,
                                   fill = AdapOpt)) +
      ggplot2::geom_smooth(method = "loess", formula = 'y ~ x') +
      ggplot2::geom_point(aes(colour = AdapOpt)) +
      facet_grid(env_group ~ SWSDLName, scale = "free_y") +
      #ggplot2::labs(y = paste0(y_lab, prepped$ylab_append)) +
      #ggplot2::scale_y_continuous(trans = 'identity') +
      ggplot2::scale_fill_manual(values = AdapOpt_pal, name = "Adaptation Options:") +
      ggplot2::scale_colour_manual(values = AdapOpt_pal, name = "Adaptation Options:") +
      #ggplot2::scale_x_discrete(guide = ggplot2::guide_axis(angle = 45)) +
      ggplot2::labs(y = "Proportion EWR achieved (relative to base)",
                    x = 'Change in natural flow\n(relative to base; excludes adaptation)') +
      #ggplot2::scale_color_identity() +
      theme_werp_toolkit(#axis.ticks.x = element_blank(), 
                         #axis.text.x=element_blank(),
                         #axis.title.x = element_blank(),
                         legend.position="right")+
      guides(fill=guide_legend(nrow=4,byrow=TRUE)) +
      scale_y_continuous(trans='log10') #+
      #scale_x_continuous(trans='log10') #+
      # geom_vline(xintercept = c(0.5, 1, 2))#+#+ 
      #scale_x_discrete(position = "top", name = "Climate & Adaptation Option Scenario")


# MIN_delta_dif <- min(env_group_sdl_to_plot$delta_diff)
# 
# #to make range the same for top thing
# MIN_MAX_DATA <- filter(env_group_sdl_to_plot, scenario != "MAX") |>
#   filter(delta_diff == min(delta_diff) | delta_diff == max(delta_diff)) |>
#   distinct(delta_diff)
# 
# 
#  scenario_deltas_log <- ggplot(data = filter(scenarios, scenario  %in% scenario_to_plot), 
#                            mapping = aes(x = delta_diff+10, y = 1)) +
#       geom_point(data = MIN_MAX_DATA,  mapping = aes(x = delta_diff+10, y = 1), colour = "white")+
#                     geom_vline(xintercept = filter(scenarios, scenario  %in% scenario_to_plot)$delta_diff+10) +
#                     ggrepel::geom_text_repel(label = filter(scenarios, scenario  %in% scenario_to_plot)$Climate_AdapOpt, size = 3, angle = 90,
#                                              direction='x')+ 
#                     theme_werp_toolkit(legend.position = "none", axis.title=element_blank(),
#                     axis.text=element_blank(), axis.ticks=element_blank())+
#       #scale_y_continuous(trans='log10') 
#       scale_x_continuous(trans='log10') 



 #Fig_9 <- scenario_deltas_log / sdl_lm_groups + plot_layout(ncol = 1, heights = c(1,15)) + theme(legend.position = "right")

 saveRDS(sdl_lm_groups, file = file.path(comp_results, "Fig_9.Rdata"))
 sdl_lm_groups
 
```

```{r}
#aggregation table
Fig_9_table <- data.frame(Scale = c("Scenario", rep("", times = 1), 
                                    "Space", rep("", times = 2), 
                                     "Theme", rep("", times = 4)),
                                 Things = c("Climate", "Adaptation option", 
                                          "Gauges", "Planning units", "Catchment", 
                                          "EWR timing (wet/dry year)", "EWR", 
                                          "Environmental objectives", "Environmental targets", 
                                          "Environmental total"),
                                 Fig9 = c("Difference from base [x-axis]", "Difference from base [x-axis; linear fit color]",
                                           "ArithmeticMean aggregation", "[points; color]", NA,
                                           "CompensatingFactor aggregation","ArithmeticMean aggregation",
                                           "ArithmeticMean aggregation relative to base [y-axis]",
                                           "[horizontal facets]", 
                                           NA))

saveRDS(Fig_9_table, file = file.path(comp_results, "Fig_9_table.Rdata"))
```

```{r}
# summing over planning units and Env groups
Fig_10 <- ggplot(data = filter(env_theme_catchment_to_plot, scenario != "MAX"), aes(x = Climate, y = AdapOpt, fill = proportion_ewr_achieved)) + 
  geom_tile() + theme_werp_toolkit() +
  scale_fill_paletteer_c('scico::berlin')+
  labs(x = "Climate scenario", y = "Adaptation Option", fill = "Proportion EWR achieved")

saveRDS(Fig_10, file = file.path(comp_results, "Fig_10.Rdata"))
Fig_10
 
 
 # Could may quantitative version but need to work out how to interpolate.
 # ggplot(data = filter(env_theme_catchment_to_plot, scenario != "MAX"), aes(x = log10(flow_multiplier+1), y = log10(flow_addition+1), fill = ewr_achieved)) + geom_tile()+
 
#TO DO::::: For Fig 10, Iâ€™m not sure that the max square is adding much. I think you could just have the matrix minus that theoretical maximum given that you hit it with the upper right most box anyway.

```

```{r}
#aggregation table
Fig_10_table <- data.frame(Scale = c("Scenario", rep("", times = 1), 
                                    "Space", rep("", times = 2), 
                                     "Theme", rep("", times = 4)),
                                 Things = c("Climate", "Adaptation option", 
                                          "Gauges", "Planning units", "Catchment", 
                                          "EWR timing (wet/dry year)", "EWR", 
                                          "Environmental objectives", "Environmental targets", 
                                          "Environmental total"),
                                 Fig10 = c("[x-axis]", "[y-axis]",
                                           "ArithmeticMean aggregation", "ArithmeticMean aggregation", NA,
                                           "CompensatingFactor aggregation","ArithmeticMean aggregation",
                                           "ArithmeticMean aggregation",
                                           "ArithmeticMean aggregation [color]", 
                                           NA))

saveRDS(Fig_10_table, file = file.path(comp_results, "Fig_10_table.Rdata"))
```

```{r}
#| echo: false
#| include: false
# Causal networks

#Fig_4a
edges <- make_edges(dflist = causal_ewr, 
               fromtos = list(c('ewr_code', 'env_obj'), 
                              c('env_obj', 'Specific_goal'), 
                              c('Specific_goal', 'Target'), 
                              c('env_obj', 'target_5_year_2024')),
               gaugefilter = gauges_to_plot[1]) 

nodes <- make_nodes(edges)


Fig_4a <- make_causal_plot(nodes,
                 edges,
                 focalnodes = filter(nodes, NodeType == "ewr_code")$Name,
                 edge_pal = 'black',
                 node_pal = 'white',
                 render = FALSE
                 ) 

Fig_4a%>% 
  DiagrammeR::render_graph()

# FYI, there are plot export functions in the toolkit that render to vector graphics.
DiagrammeR::export_graph(Fig_4a,
file_name = file.path(comp_results,"Fig_4a.png"),
file_type = "png")

```

```{r}
#| echo: false
#| include: false
# Causal networks
#Fig_4b
edges_s <- make_edges(dflist = causal_ewr, 
               fromtos = list(c('ewr_code', 'env_obj'), 
                              c('env_obj', 'Target')),
               gaugefilter = gauges_to_plot[1])


edges_targets <- make_edges(dflist = causal_ewr, 
               fromtos = list(c('env_obj', 'Target')),
               gaugefilter = gauges_to_plot[1])

#edges <- filter(edges, gauge == gauges_to_plot[1])

nodes_s <- make_nodes(edges_s)

gauge_nodes_EWRs <- filter(agged_data$ewr_code, gauge == gauges_to_plot[1] & scenario == scenario_to_plot[4]) |>
  as_tibble()|>
  select(ewr_code, ewr_achieved) |>
  rename(Name = ewr_code)

gauge_nodes_Env_objs <- filter(agged_data$env_obj, gauge == gauges_to_plot[1] & scenario == scenario_to_plot[4]) |>
  as_tibble()|>
  select(env_obj, ewr_achieved)|>
  rename(Name = env_obj)

gauge_nodes_Targets <- filter(agged_data$env_obj, gauge == gauges_to_plot[1] & scenario == scenario_to_plot[4]) |>
  left_join(edges_targets, by = c("env_obj" = "from")) |>
  rename(Name = to )|>
  as_tibble()|>
  group_by(Name)|>
  mutate(Name = case_when(env_obj == "EF3" ~ "Priority ecosystem function", 
                            env_obj == "NV2" ~ "Native vegetation",
                            .default = Name))|>
  summarise(ewr_achieved = mean(ewr_achieved))

gauge_nodes_values <-  bind_rows(gauge_nodes_EWRs, gauge_nodes_Env_objs, gauge_nodes_Targets)
nodes_s <- left_join(nodes_s, gauge_nodes_values)

Fig_4b <- make_causal_plot(nodes_s,
                 edges_s,
                 #focalnodes = c('NF4', 'Sloanes froglet'),
                 edge_pal = 'black',
                 node_pal = list(value = 'scico::berlin'),
                 node_colorset = 'ewr_achieved', render = FALSE
                 ) 

Fig_4b%>% 
  DiagrammeR::render_graph()

DiagrammeR::export_graph(Fig_4b,
file_name = file.path(comp_results,"Fig_4b.png"),
file_type = "png")

```

```{r}
library(english)

proj_meta <- list(Plannning_units = knitr::combine_words(SWSDLName_to_plot),
                  n_Plannning_units = english::words(length(SWSDLName_to_plot)),
                  gauges_to_plot = knitr::combine_words(gauges_to_plot),
                  n_gauges_to_plot = english::words(length(gauges_to_plot)),
                  n_gauges = length(unique(scenehydros$gauge)),
                  Max_scenario = max(scenarios$flow_multiplier),
                  Min_scenario = min(scenarios$flow_multiplier)
                  )

yaml::write_yaml(proj_meta, 
file = file.path(comp_results, 'project_metadata.yml'))


## Subset for demo

# We have a lot of hydrographs, so for this demonstration, we will often use a subset.

# gauges_to_plot <- c('412002', '419001')#, '422028', '421001')
# scenario_to_plot <- c("climatedown2adapt0", "climatedown2adapt201", "climatedown2adapt6001",
#                       "climatebaseadapt0", "climatebaseadapt201", "climatebaseadapt6001",
#                       "climateup2adapt0", "climateup2adapt201", "climateup2adapt6001")
# 
# scenario_labels_to_plot <- sort(filter(scenarios, scenario %in% c(scenario_to_plot))$Climate_AdapOpt)
# 
# SWSDLName_to_plot <- c("Macquarieâ€“Castlereagh", "Lachlan", "Namoi")
# 
# catch_demo <- sdl_units %>% 
#   dplyr::filter(SWSDLName %in% SWSDLName_to_plot)

```
