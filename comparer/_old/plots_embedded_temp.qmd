---
title: "AllPlots"
author: "Galen"
format: 
  html:
    embed-resources: true
editor: visual
---

```{r}
#| message: false
library(werptoolkitr)
library(ggplot2)
library(dplyr)
library(sf)
```

# Overview

This notebook provides examples of creating bar plots, e.g. plots with one quantitative y-axis for outcome, and a qualitative x-axis. The x-axis is often, but not always, scenario. We also demonstrate here the ability to use color and different color palettes to include additional information, including spatial unit and type of response.

For a quantitative x-axis, we would typically use [line plots](../comparer/line_plots.qmd).

# Demonstration setup

As usual, we need paths to the data.

```{r}
project_dir <- file.path("more_scenarios")
hydro_dir <- file.path(project_dir, "hydrographs")
agg_dir <- file.path(project_dir, "aggregator_output")
```

## Scenario information

This will be attached to metadata, typically. For now, I'm just using it for diagnostic plots and the demonstration data is simple, so make it here.

```{r}
multipliers <- c(1.1, 1.25, 1.5, 2)

scenemults <- c(1 / rev(multipliers), 1, multipliers)

scenenames <- c(
  paste0("down", as.character(rev(multipliers))),
  "base",
  paste0("up", as.character(multipliers))
) |>
  stringr::str_replace("\\.", "_")


scenarios <- tibble::tibble(scenario = scenenames, delta = scenemults)
```

## Subset for demo

We have a lot of hydrographs, so for this demonstration, we will often use a subset.

```{r}
gauges_to_plot <- c("412002", "419001", "422028", "421001")
```

# Standard scenario appearance

We want to have a consistent look for the scenarios across the project, with a logical ordering and standard colors. In future, this will potentially be able to be parsed from metadata, but at present we will define these properties manually. They are not included in the {werptoolkitr} package because they are project/analysis- specific.

```{r}
sceneorder <- forcats::fct_reorder(scenarios$scenario, scenarios$delta)
scene_pal <- make_pal(unique(scenarios$scenario),
  palette = "ggsci::nrc_npg",
  refvals = "base", refcols = "black"
)
```

```{r}
aggseq <- list(
  ewr_code = c("ewr_code_timing", "ewr_code"),
  env_obj = c("ewr_code", "env_obj"),
  sdl_units = sdl_units,
  Specific_goal = c("env_obj", "Specific_goal"),
  catchment = cewo_valleys,
  Objective = c("Specific_goal", "Objective"),
  mdb = basin,
  target_5_year_2024 = c("Objective", "target_5_year_2024")
)


funseq <- list(
  c("CompensatingFactor"),
  c("ArithmeticMean"),
  c("ArithmeticMean"),
  c("ArithmeticMean"),
  list(wm = ~ weighted.mean(.,
    w = area,
    na.rm = TRUE
  )),
  c("ArithmeticMean"),
  list(wm = ~ weighted.mean(.,
    w = area,
    na.rm = TRUE
  )),
  c("ArithmeticMean")
)
```

# Make bar plots

## Choosing example data

First, we read in the aggregated data and make a simple demonstration bar plot. There is example data provided by the toolkit (`agg_theme_space` and `agg_theme_space_colsequence`), but to continue with the demonstration, we will use the aggregations created here in the [interleaved aggregation notebook](../aggregator/theme_space_agg.qmd).

*Note*- to `readRDS` `sf` objects, we need to have `sf` loaded.

```{r}
agged_data <- readRDS(file.path(agg_dir, "summary_aggregated.rds"))
```

That has all the steps in the aggregation, so we'll choose one (the Objective theme scale at the basin spatial scale, `agged_data$mdb`) for the first set of plots and another (`agged_data$sdl_units` at the SDL unit scale and `env_obj` theme scale for the second set of plots. This finer scale lets us look at complicating factors like multiple spatial units and grouping outcomes.

To make these examples more easily, we create some slightly simpler dataframes here for those examples, but this isn't really necessary- small data manipulations are easily piped in to `plot_outcomes`. The basin-scale needs a bit of cleanup because Objectives (and many of the other categories other than codes, e.g. yearly targets) are really long. We could fold them in the facet labels with `ggplot2::label_wrap_gen()`, but they're so long it blocks out the plots. Ideally, we would use descriptive short names for each, but that's a large manual job to assign them. For this demonstration, I'll just cut them off and make them unique, but we need a better solution. The SDL units data is given a grouping column that puts the many `env_obj` variables in groups defined by their first two letters, e.g. `EF` for Ecosystem Function.

If we had used multiple aggregation functions at any step, we should filter down to the one we want here, but we only used one for this example.

```{r}
#| echo: false
# make the super long names shorter but less useful.
basin_to_plot <- agged_data$mdb %>%
  dplyr::filter(!is.na(Objective)) %>%
  dplyr::mutate(Objective = stringr::str_trunc(Objective, 15)) %>%
  dplyr::group_by(scenario, Objective) %>%
  dplyr::mutate(id = as.character(row_number())) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(Objective = stringr::str_c(Objective, "_", id)) %>%
  dplyr::select(-id)

# Create a grouping variable
obj_sdl_to_plot <- agged_data$sdl_units |>
  left_join(scenarios) |>
  dplyr::mutate(env_group = stringr::str_extract(env_obj, "^[A-Z]+")) |>
  dplyr::filter(!is.na(env_group)) |>
  dplyr::arrange(env_group, env_obj)
```

## Scenario fills

### Basin scale

We can make plots looking at how scenarios differ for each of the outcome categories. This uses `facet_wrapper` to just wrap the single facet axis, looking at the basin scale and Objectives first. If we had more than one spatial unit, we would need to either filter to a target unit or facet by them. As with {ggplot2} itself, we tend to use `facet_wrap` for single-variable facetting and `facet_row` and `facet_grid` for specifying rows and columns, though here we use `facet_row` and `facet_col` to feed `facet_grid`. Plots at the basin scale are the simplest because we don't have to worry about different bars for different spatial units.

The `colorset` argument is the column that determines color, while the `pal_list` defines those colors, here as a named `colors` object, but as we see below it can also be palette names. The `sceneorder` argument lets us explicitly set the order of the scenarios. This is typically easiest to have a `Factor` object with the scenarios and their orders, as here. But we can also just use a character vector (demonstrated later).

```{r}
#| message: false
plot_outcomes(basin_to_plot,
  y_col = "ewr_achieved",
  facet_wrapper = "Objective",
  colorset = "scenario",
  pal_list = scene_pal,
  sceneorder = sceneorder
)
```

We retain the axis names as-is from the incoming dataframe, as they provide the true meaning of each value. But we can change them, either inside the `plot_outcomes` function or post-hoc. We can also set the `sceneorder` with a character vector if that's easier than setting up a Factor.

```{r}
#| message: false
plot_outcomes(basin_to_plot,
  y_col = "ewr_achieved",
  y_lab = "Proportion Objectives\nAchieved",
  x_lab = "Scenario",
  color_lab = "Scenario",
  facet_wrapper = "Objective",
  colorset = "scenario",
  pal_list = scene_pal,
  sceneorder = c("down2", "down1_5", "down1_25", "down1_1", "base", "up1_1", "up1_25", "up1_5", "up2")
)
```

Because these are just ggplot objects, we can also change the labels outside the function, which can be very useful for checking that each axis is in fact what we think it is before giving it clean labels.

```{r}
#| message: false
scenebar <- plot_outcomes(basin_to_plot,
  y_col = "ewr_achieved",
  facet_wrapper = "Objective",
  colorset = "scenario",
  pal_list = scene_pal,
  sceneorder = sceneorder
)

scenebar + labs(x = NULL, y = "Proportion\nObjectives Achieved")
```

Another approach is to put the outcomes on the x-axis, and color by scenario. This requires using the special `scene_pal` argument currently instead of `pal_list`. This is a bit of a historical holdover and will be made more general.

```{r}
#| message: false
plot_outcomes(basin_to_plot,
  y_col = "ewr_achieved",
  x_col = "Objective",
  colorset = "scenario",
  scene_pal = scene_pal,
  sceneorder = sceneorder
)
```

Using dodged bars can allow clearer comparisons, particularly accentuating the variation in sensitivity of the different outcomes to the scenarios, though there are a lot of bars to try to read here.

```{r}
#| message: false
plot_outcomes(basin_to_plot,
  y_col = "ewr_achieved",
  x_col = "Objective",
  colorset = "scenario",
  scene_pal = scene_pal,
  sceneorder = sceneorder,
  position = "dodge"
)
```

### SDL units

We can use the aggregation step of `env_obj` and SDL units to demonstrate plotting that not only addresses the outcomes for scenarios, but how they differ across space. I'll often use subsets of the `env_obj` codes here to keep the number of plots visible.

First, we look at how the different scenarios perform for the Ecosystem Function objectives in each SDL unit

```{r}
#| message: false
obj_sdl_to_plot %>%
  filter(grepl("^EF", env_obj)) %>%
  plot_outcomes(
    y_col = "ewr_achieved",
    facet_col = "env_obj",
    facet_row = "SWSDLName",
    colorset = "scenario",
    pal_list = scene_pal,
    sceneorder = sceneorder
  )
```

We address a few ways to handle groups of outcome variables, one of the simplest is to simply facet these plots by those groups, with all the outcomes in the group getting their own bars. This puts the objectives on x and colors by scenario, with the groups accentuated by facets. These can be stacked (`position = 'stack'`- the default) or dodged (demonstrated here).

```{r}
dodgefacet <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "env_obj",
    colorset = "scenario",
    facet_row = "SWSDLName",
    facet_col = "env_group",
    scales = "free_x",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    position = "dodge"
  )

dodgefacet + theme(legend.position = "bottom") +
  labs(x = "Environmental Objective")
```

# Colors from outcomes

Rather than facetting, we can stack each of the outcome categories (here, Objectives). To do this, we simply change the `colorset` to "Objective" instead of 'scenario' (the default `x_col` is scenario, so it remains on x). We also change the `pal_list` to a {paletteer} name, providing the palette from which to choose colors for each Objective. This yields a more compact plot that shows overall outcomes at the expense of making it harder to see what any particular objective is doing, particularly with many outcomes and long names. But with careful selection of a color palette and cleaner naming (or just far fewer categories), this could be a very useful approach.

```{r}
#| message: false
plot_outcomes(basin_to_plot,
  y_col = "ewr_achieved",
  colorset = "Objective",
  pal_list = list("scico::oslo"),
  sceneorder = sceneorder
) +
  guides(fill = guide_legend(ncol = 2))
```

In another example of colors from other information in the data, when we have multiple spatial units we might color by them instead of coloring by outcome category. Here, we show how to color by SDL unit (SWSDLName) instead of `env_obj`. That still stacks the `env_obj` outcomes in each catchment, but coloring them all the same, and so is itself a sort of simple aggregation.

```{r}
#| message: false
plot_outcomes(obj_sdl_to_plot,
  y_col = "ewr_achieved",
  colorset = "SWSDLName",
  pal_list = list("ggsci::default_jama"),
  sceneorder = sceneorder
)
```

That shows that while all SDL units are affected by the changes in the flow, the Lachlan is less sensitive.

We can also use `position = 'dodge'` to have side-by-side bars instead of stacked. Note that in this case, where we're coloring by SDL unit but there are many `env_obj` values, those `env_obj` no longer stack, and so we have to manually stack them by calculating their sum. This would not be the case if we were coloring by individual rows (`env_obj`)- see examples of that below.

```{r}
#| message: false

obj_sdl_to_plot %>%
  group_by(SWSDLName, scenario) %>%
  summarise(ewr_achieved = sum(ewr_achieved, na.rm = TRUE)) %>%
  ungroup() %>%
  plot_outcomes(
    y_col = "ewr_achieved",
    colorset = "SWSDLName",
    pal_list = list("calecopal::lake"),
    sceneorder = sceneorder,
    position = "dodge"
  )
```

We are about to consider grouped colors as a way to assign different palettes to different groups. But a simpler way to show outcomes groups is to color by the groups directly if we don't care what the individual `env_obj`s are doing between them. This is very similar to the plots coloring by SDL unit above.

```{r}
plot_outcomes(obj_sdl_to_plot,
  y_col = "ewr_achieved",
  colorset = "env_group",
  pal_list = list("scico::berlin"),
  facet_col = "SWSDLName",
  facet_row = ".",
  sceneorder = sceneorder
)
```

## Grouped colors

We have the ability to assign different color palettes to different sets of outcomes, yielding what is essentially another axis on which we can plot information. We use this same ability across a number of plot types, particularly [causal networks](../causal_networks/causal_plots.qmd). For example, we might categorize the `env_obj` outcomes into the larger scale groups (e.g. 'NF', 'EF', etc). We can then assign each of these a separate palette, and so the individual `env_obj`s get different colors chosen from different palettes.

Achieving this requires specifying two columns- the `colorset`, as above, is the column that determines color. The `colorgroups` column specifies the groupings of those `colorset` values, and so what palette to use. Thus, the `pal_list` needs to be either length 1 (everything gets the same palette) or `length(unique(data$colorgroups))`. Note also that the `colorset` values must be unique to `colorgroups`- this cannot be a one-to-many mapping because each `colorset` value must get a color from a single palette defined by the `colorgroup` it is in.

We demonstrate with `env_obj` variables mapped to larger environmental groups, making it easier to see at a glance the sorts of environmental objectives that are more or less affected, while also allowing views of the individual environmental objectives. Here we use `facet_col` and `facet_row` to ensure the SDL units don't wrap around. We made the `env_groups` column when we chose the data initially.

```{r}
#| message: false

# Create a palette list
env_pals <- list(
  EF = "grDevices::Purp",
  NF = "grDevices::Mint",
  NV = "grDevices::Burg",
  OS = "grDevices::Blues",
  WB = "grDevices::Peach"
)

# need to facet by space sdl unit and give it the colorgroup argument to take multiple palettes
sdl_stack <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    colorgroups = "env_group",
    colorset = "env_obj",
    pal_list = env_pals,
    facet_col = "SWSDLName",
    facet_row = ".",
    sceneorder = sceneorder
  )
sdl_stack
```

Adding facetting by those groups can make that easier to read if the goal is to focus on changes within groups, but more plots.

```{r}
#| message: false

obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    colorgroups = "env_group",
    colorset = "env_obj",
    pal_list = env_pals,
    facet_col = "SWSDLName",
    facet_row = "env_group",
    sceneorder = sceneorder
  )
```

We could also split those bars sideways instead of stack them, but that likely makes more sense if there are fewer categories than here. We again use `position = 'dodge'`, but now we don't need to sum because we're stacking each row already. I've flipped the facetting and taken advantage of the fact that these are just ggplot objects to remove the legend, making it very slightly easier to read (but harder to interpret).

```{r}
#| message: false

obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    colorgroups = "env_group",
    colorset = "env_obj",
    pal_list = env_pals,
    facet_col = "env_group",
    facet_row = "SWSDLName",
    sceneorder = sceneorder,
    position = "dodge"
  ) +
  theme(legend.position = "none")
```

Another approach to groups of outcomes without the colors explicitly grouped is to not use `colorgroup`, but instead just facet by the group and give every `colorset` value a color from the same palette. Depending on the palette chosen and the breaks, this can be quicker, but will not accentuate groups as well.

```{r}
#| message: false
obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    colorgroups = NULL,
    colorset = "env_obj",
    pal_list = list("scico::berlin"),
    facet_row = "SWSDLName",
    facet_col = "env_group",
    scales = "free_x",
    scene_x = FALSE,
    scene_pal = scene_pal,
    sceneorder = sceneorder
  )
```

These plots are interesting, but in typical use, the plots above using facets for the groups or coloring by the groups themselves are likely to be easier to read, unless we really are interested in this level of granularity. Whatever approach we choose for a given plot, accentuating the differences between outcome groups can be a powerful interpretation tool.

## Manual color definition

Though the above examples using {paletteer} palettes are the easiest way to specify coloring, we don't have to let the palettes auto-choose colors, and can instead pass `colors` objects, just as we do for scenarios. This can be particularly useful with small numbers of groups (defining too many colors is cumbersome- that's what palettes are for) when we want to control which is which. Just as with scenarios, we use `make_pal` . Here, we will use 'scico::berlin' as the base, but define several 'reference' values manually. This demonstration uses `includeRef = TRUE` so we *replace* the palette values with the refs, rather than choose them from the set of values with refs removed. This tends to yield better spread of colors (and lets us sometimes ref colors and sometimes not if we also used `returnUnref`). For example, maybe we want to sometimes really accentuate ecosystem function and native vegetation, but not in all plots.

First, we create the palettes with and without the (garish) ref values.

```{r}
obj_pal <- make_pal(
  levels = unique(obj_sdl_to_plot$env_group),
  palette = "scico::lisbon",
  refvals = c("EF", "NV"), refcols = c("purple", "orange"), includeRef = TRUE, returnUnref = TRUE
)
```

Then we can create an accentuated plot sometimes, if, perhaps, we want to highlight how EF performed.

```{r}
#| message: false
plot_outcomes(obj_sdl_to_plot,
  y_col = "ewr_achieved",
  colorset = "env_group",
  pal_list = obj_pal$refcols,
  facet_col = "SWSDLName",
  facet_row = ".",
  sceneorder = sceneorder
)
```

But for other plots maybe we don't want that accentuation and we can use the `unrefcols` to retain the standard coloring- note that 'NF', 'OS', and 'WB' colors are unchanged.

```{r}
#| message: false
plot_outcomes(obj_sdl_to_plot,
  y_col = "ewr_achieved",
  colorset = "env_group",
  pal_list = obj_pal$unrefcols,
  facet_col = "SWSDLName",
  facet_row = ".",
  sceneorder = sceneorder
)
```

# Plotting hydrographs

We first read in the hydrographs, with a bit of standardised data processing. The `read_hydro` function knows about the standard data organisation format, and so pulls hydrographs from all scenarios.

```{r}
scenehydros <- read_hydro(hydro_dir, long = TRUE, format = "csv")
```

Now, we can make a simple plot using the standard format and colors

```{r}
plot_hydrographs(scenehydros, gaugefilter = gauges_to_plot, colors = scene_pal)
```

The `plot_hydrographs` function has a `scenariofilter` argument if we want to drop some scenarios, which also shows that the scenario colors stay consistent, even if some are missing. Further, we can access the `scales` argument from `ggplot2::facet_*` and `trans` arguments of of `ggplot2::cale_y_continuous` (though just for the y-axis).

```{r}
plot_hydrographs(scenehydros,
  gaugefilter = gauges_to_plot,
  colors = scene_pal,
  scenariofilter = c("up2", "down2"),
  scales = "free_y", transy = "log10"
)
```

# Baselining

All plotting functions provide the ability to set a base level and calculate changes in the other levels. Here, we'll show how that works under the hood, though it is usually done directly in the `plot_*` call, as we show later.

The baseline can be either a scenario name or a scalar. We could potentially use something else like historical daily means, but that is not currently implemented, largely because it hasn't yet been necessary- one of the scenarios is always an obvious baseline.

Internally, the `plot_*` functions call `baseline_compare`, but `baseline_compare` can be used externally as well (and is actually quite useful in a number of places to baseline long data).

For example, we might want to calculate the difference between the modified scenarios and the `base` scenario. To do this, we simply pass in the data, the columns defining the groups `compare_col`, and the `base_lev`, that is, the value in `compare_col` that is the baseline situation. We also need to tell it which column contains the values, and the function `comp_fun` we want to use for the comparison. Here, we ask for the `difference` to the baseline provided by the base scenario.

```{r}
dif_flow <- baseline_compare(scenehydros,
  compare_col = "scenario",
  base_lev = "base",
  values_col = "flow", comp_fun = difference
)
```

Now we can feed the dif_flow dataframe to `plot_hydrographs` directly. We see that, as expected, `base` is now a flat line at 0, while up2 and down2 go up and down, respectively.

```{r}
plot_hydrographs(dif_flow,
  gaugefilter = gauges_to_plot,
  y_col = "difference_flow",
  colors = scene_pal
)
```

In practice, we would typically let the baselining happen internally to the `plot_*` functions so we aren't carrying around and keeping track of a bunch of altered dataframes. To replicate the above plot, we only have to feed `plot_hydrographs` the `base_lev` and `comp_fun` arguments- it automatically uses the `scenario` column as the groupings. This is also true for `plot_outcomes`. If we want to do something more unusual with the baselining, we will need to do it external to the `plot_*` functions, at least until it becomes common enough for us to decide to incorporate the additional parsing.

```{r}
plot_hydrographs(scenehydros,
  gaugefilter = gauges_to_plot,
  colors = scene_pal,
  base_lev = "base",
  comp_fun = difference
)
```

The other default comparison function is `relative` , which has an `add_eps` argument to pull zeros up a bit and avoid divide-by-0 infinities. This is a bit silly to use for this test case, since the test case was created multiplicatively, so all `down2` values are 0.5\*base and `up2` values are 2\*base.

```{r}
plot_hydrographs(scenehydros,
  gaugefilter = gauges_to_plot,
  y_col = "flow", colors = scene_pal,
  base_lev = "base", comp_fun = relative,
  add_eps = min(scenehydros$flow[scenehydros$flow > 0]) / 10
)
```

Finally, as with other situations where we can pass functions, we can create a custom comparison function. The ability to pass anonymous functions in a list a la the aggregator is not yet implemented here. The two above are the logical functions to use, but for demonstration purposes, let's create a function that finds the square root of the absolute value of the difference.

```{r}
sqrtdif <- function(x, y) {
  sqrt(abs(x - y))
}
```

```{r}
plot_hydrographs(scenehydros,
  gaugefilter = gauges_to_plot,
  colors = scene_pal,
  base_lev = "base",
  comp_fun = sqrtdif
)
```

One way this could be very useful is for lagged or windowed operations, which we do here very simply by getting the difference to the baseline one day previous. The use in practice would need to be developed carefully to address specific questions.

```{r}
lagdif <- function(x, y) {
  x - lag(y)
}
```

```{r}
plot_hydrographs(scenehydros,
  gaugefilter = gauges_to_plot,
  colors = scene_pal,
  base_lev = "base",
  comp_fun = lagdif
)
```

# Make line plots

We make two sorts of line plots- either straight lines through all the data points, which shows exactly what the results are, and 'smoothed' lines, which are fit to the data in some way to summarise a group of outputs. These can yield smoothed curves, but can also be linear regressions or other fits available from `ggplot2::geom_smooth`. These smooths tend to be dangerous (they inherently hide data and are a form of summary), but can also be very powerful and cleaner visualizations if used appropriately.

## Lines through all data

A simple plot would be to look at all the outcomes, separated by color. We've given the scenarios different shapes, but that's not really necessary- they are different along x. Even this simple plot is quite infomative- we can see that the `env_obj` outcomes are differently sensitive to both decreases and increases in flow, and that this differs across space.

```{r}
sdl_line <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    colorgroups = NULL,
    colorset = "env_obj",
    pal_list = list("scico::berlin"),
    facet_row = "SWSDLName",
    facet_col = ".",
    scene_pal = scene_pal,
    sceneorder = sceneorder
  )

sdl_line
```

We might not care so much about individual outcomes, but about their groupings, and we can plot those in color by changing `colorset = 'env_group'`. We need to use `point_group` here to separate out the points for each `env_obj`.

This plot also demonstrates the use of some additional arguments. We're also using `transx` to log the x-axis, which is particularly appropriate for the multiplicative flow scaling in this demonstration. We also log the y-axis with `transy` since we're using a `comp_fun` (`relative`) to look at the multiplicative shift in each env_obj to baseline. We're using various `*_lab` arguments to adjust the labelling. We also need to use the (poorly documented) `group_cols` argument to specify unique rows. This is historical and only applies to baselining the data. It will be auto-found in a future update.

Scientifically, one important thing to note here is that the range on y (0-10) is much greater than the range on x (0.3 - 3), and so (unsurprisingly), some outcomes are disproportionately impacted by flow. Other outcome values are less than the relative shift in flow, and so there are others that are disproportionately insensitive. These disproportionate responses also depend on whether flows decrease or increase- they are not symmetric.

```{r}
#| warning: false
sdl_line_options <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transy = "log10",
    color_lab = "Environmental\ngroup",
    colorset = "env_group",
    pal_list = list("scico::berlin"),
    point_group = "env_obj",
    facet_row = "SWSDLName",
    facet_col = ".",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    group_cols = c("env_obj", "polyID")
  )

sdl_line_options
```

We can also give the groups different palettes, as demonstrated more completely in the [bar plots](bar_plots.qmd) and [causal networks](../causal_networks/causal_plots.qmd). Now, we don't need `point_group` anymore, since the colors are assigned to the unique `env_obj`s.

```{r}
#| label: fig-env-grouped
#| fig-cap: Change in proportion of environmental objectives met in each scenario, relative to the historical baseline, dependent on the shift in flow. Groups of environmental objectives plotted from different color palettes.
#| warning: false

# Create a palette list
grouplist <- list(
  EF = "grDevices::Purp",
  NF = "grDevices::Mint",
  NV = "grDevices::Burg",
  OS = "grDevices::Blues",
  WB = "grDevices::Peach"
)

sdl_line_groups <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transy = "log10",
    color_lab = "Environmental\ngroup",
    colorgroup = "env_group",
    colorset = "env_obj",
    pal_list = grouplist,
    facet_row = "SWSDLName",
    facet_col = ".",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    group_cols = c("env_obj", "polyID")
  )

sdl_line_groups
```

That's fairly complex, so we can facet it, as we did with the [bars](../comparer/bar_plots.qmd) to make the individual `env_obj`s easier to see.

```{r}
#| label: fig-env-group-facet
#| fig-cap: Change in proportion of environmental objectives met in each scenario, relative to the historical baseline, dependent on the shift in flow. Groups of environmental objectives plotted from different color palettes and facetted for easier visualisation.
#| warning: false
sdl_line_groups_facet <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transy = "log10",
    color_lab = "Environmental\ngroup",
    colorgroup = "env_group",
    colorset = "env_obj",
    pal_list = grouplist,
    facet_row = "SWSDLName",
    facet_col = "env_group",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    group_cols = c("env_obj", "polyID")
  )

sdl_line_groups_facet
```

The above is typically how we would go about this facetting, but it is worth reiterating that these are just ggplots, and so we can post-hoc add facetting. Using the version with only spatial facetting ( @fig-env-grouped ), we can add the `env_group` facet on, matching @fig-env-group-facet . Note that we re-build all the facets here, due to the specification of `ggplot2::facet_grid`.

```{r}
#| warning: false
sdl_line_groups + facet_grid(SWSDLName ~ env_group)
```

As with the [bar plots](../comparer/bar_plots.qmd), we can color by any column we want, and the spatial units is a logical choice. We again use `point_group`, since multiple `env_obj` rows are mapped to each color. The overplotting gets unreadable here and so I've retained the facetting, but if we were looking at a subset, the line colors could be enough (or if we are summarising the data with a smoother- see below).

```{r}
#| label: fig-sdl-colors
#| fig-cap: Change in proportion of environmental objectives met in each scenario, relative to the historical baseline, dependent on the shift in flow. Colors indicate SDL unit, each line is an `env_obj`.
#| warning: false
sdl_line_sdl <- obj_sdl_to_plot |>
  filter(env_group == "EF") |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transy = "log10",
    color_lab = "SDL unit",
    colorset = "SWSDLName",
    pal_list = list("ggsci::default_jama"),
    point_group = "env_obj",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    group_cols = c("env_obj", "polyID")
  )

sdl_line_sdl
```

## Smoothing (fit lines)

We can use smoothing to fit lines through multiple points, e.g. if we want to group data in some way- maybe use it to put a line through the color groups and ignore individual levels. **This is dangerous**- it's an aggregation. But it can also be very informative, and we can show the individual data points to avoid misleading information. We demonstrate here using them to illustrate unique outcomes, as well as more typical uses as lines of best fit that aggregate over a number of outcomes.

To get smoothed lines, we use `smooth = TRUE`. By default, that produces a loess fit (as with `ggplot2::geom_smooth`, but we can also pass `smooth_method`, which is the `method` argument to `ggplot::geom_smooth`, and so allows things like `lm` and `glm` fits.

### Unique points

Fitting lines through unique points at each scenario level is a bit contrived, but it can be useful if we want to accentuate nonlinear relationships. Linear fits are possible too, though these are typically less useful.

With unique points, this just fits a single curved line through each `env_obj`. Recapitulating the above, we color here from SDL unit.

```{r}
#| warning: false
#| message: false
sdl_smooth_sdl <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    color_lab = "Catchment",
    colorgroups = NULL,
    colorset = "SWSDLName",
    point_group = "env_obj",
    pal_list = list("ggsci::default_jama"),
    facet_row = "env_group",
    facet_col = ".",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "difference",
    group_cols = c("env_obj", "polyID"),
    smooth = TRUE
  )

suppressWarnings(print(sdl_smooth_sdl))
```

And we can do the same for environmental groupings.

```{r}
sdl_smooth_groups <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    color_lab = "Environmental grouping",
    colorgroups = NULL,
    colorset = "env_group",
    point_group = "env_obj",
    pal_list = list("scico::berlin"),
    facet_row = "env_group",
    facet_col = "SWSDLName",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "difference",
    group_cols = c("env_obj", "polyID"),
    smooth = TRUE
  )
suppressWarnings(print(sdl_smooth_groups))
```

Using `smooth_method = 'lm'` is a linear fit. It does not recapitulates the simple lines above, however, because it fits the line through all the scenario data points, rather than simply joining them together. I have turned `smooth_se = FALSE` here because with unique groups the standard errors are enormous.

```{r}
#| message: false
sdl_lm_groups <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    color_lab = "Environmental grouping",
    colorgroups = NULL,
    colorset = "env_group",
    point_group = "env_obj",
    pal_list = list("scico::berlin"),
    facet_row = "env_group",
    facet_col = "SWSDLName",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    group_cols = c("env_obj", "polyID"),
    smooth = TRUE,
    smooth_method = "lm", smooth_se = FALSE
  )
suppressWarnings(print(sdl_lm_groups))
```

### Fit multiple points

Fitting lines is most often associated with things like regression and loess smoothing, where we use it to aggregate over a number of datapoints to find the line of best fit. We can do that here, simply by not having all points accounted for across the facetting, `point_group`, and `colorset`. *NOTE*- `group_cols` should still include unique values, because `group_cols` determines the baselining (e.g. what gets compared), not the plot groupings.

One example would be to perform the same analysis as in @fig-sdl-colors, but instead of plotting each point, fit a line to show the mean change within each SDL unit. We've pulled `env_obj` out of `point_group`, but left it in `group_cols` , because we still want each `env_obj` baselined with itself, not to the mean of `env_group`. Now, we can look at all the `env_groups`, because there are far fewer lines and so the overplotting isn't an issue.

We use a small `add_eps` to avoid zeros and allow all data to be relativised and plotted.

```{r}
#| label: fig-sdl-colors-fit
#| fig-cap: Change in proportion of environmental objectives met in each scenario, relative to the historical baseline, dependent on the shift in flow. Fits are loess smoothers. Colors indicate SDL unit, which have single lines. Each point is an `env_obj`.
#| warning: false
sdl_fit_sdl <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transy = "log10",
    color_lab = "SDL unit",
    colorset = "SWSDLName",
    pal_list = list("ggsci::default_jama"),
    facet_wrapper = "env_group",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    add_eps = min(obj_sdl_to_plot$ewr_achieved[obj_sdl_to_plot$ewr_achieved > 0],
      na.rm = TRUE
    ) / 2,
    group_cols = c("env_obj", "polyID"),
    smooth = TRUE
  )

suppressWarnings(print(sdl_fit_sdl))
```

We can make a very similar plot, looking at the environmental groups, a smooth fit of @fig-env-grouped . We use a `position` argument (which passes to {ggplot2}, and so has the same syntax) to see overplotted points, and an `add_eps` to avoid zeros to relativise and plot all the data.

```{r}
#| label: fig-env-grouped-fit
#| fig-cap: Change in proportion of environmental objectives met in each scenario, relative to the historical baseline, dependent on the shift in flow. Fits are loess smoothers. Colors indicate Environmental groups, which have single lines. Each point is an `env_obj`.
#| warning: false
sdl_fit_groups <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transy = "log10",
    color_lab = "Environmental\ngroup",
    colorset = "env_group",
    pal_list = list("scico::berlin"),
    facet_row = "SWSDLName",
    facet_col = ".",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    add_eps = min(obj_sdl_to_plot$ewr_achieved[obj_sdl_to_plot$ewr_achieved > 0],
      na.rm = TRUE
    ) / 2,
    group_cols = c("env_obj", "polyID"),
    smooth = TRUE,
    position = position_jitter(width = 0.01, height = 0)
  )

sdl_fit_groups
```

As we saw above, we can use `method = 'lm'` to plot a regression, though in general we do not expect these relationships to be linear, and mathematically characterising them will be a complex task that is not the purview of plotting (though is in the purview of the Comparer, and will be addressed once we have more complete outputs).

A linear fit of the SDL units ( @fig-sdl-colors-lm ) is one example of how this might work. It is useful to know here that deviations from a 1:1 line on logged axes as here means that the outcomes are responding disproportionately more (steeper) or less (shallower) than the underlying changes to flow.

```{r}
#| label: fig-sdl-colors-lm
#| fig-cap: Change in proportion of environmental objectives met in each scenario, relative to the historical baseline, dependent on the shift in flow. Fits are linear regressions. Colors indicate SDL unit, which have single lines. Each point is an `env_obj`.
#| warning: false
#| message: false
sdl_lm_sdl <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transy = "log10",
    color_lab = "SDL unit",
    colorset = "SWSDLName",
    pal_list = list("ggsci::default_jama"),
    facet_wrapper = "env_group",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    add_eps = min(obj_sdl_to_plot$ewr_achieved[obj_sdl_to_plot$ewr_achieved > 0],
      na.rm = TRUE
    ) / 2,
    group_cols = c("env_obj", "polyID"),
    smooth = TRUE,
    smooth_method = "lm"
  )

suppressWarnings(print(sdl_lm_sdl))
```

# Make maps

A minimal map of polygon aggregations with the basin in the background- we use `underlay` and `overlay` lists to put other layers in the background/foreground. Because maps lose two dimensions, we subset to the Waterbirds grouping to reduce dimensionality.

```{r}
obj_sdl_to_plot |>
  dplyr::filter(env_group == "WB") |> # Need to reduce dimensionality
  plot_outcomes(
    y_col = "ewr_achieved",
    y_lab = "Proportion EWR\nachieved",
    x_col = "map",
    colorgroups = NULL,
    colorset = "ewr_achieved",
    pal_list = list("scico::berlin"),
    facet_col = "env_obj",
    facet_row = "scenario",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    underlay_list = list(
      underlay = basin,
      underlay_pal = "azure"
    )
  )
```

A minimal map can be created with gauges as the focal spatial unit, e.g. before any spatial aggregation has occurred.

```{r}
agged_data$env_obj |> # for readability
  dplyr::filter(env_obj == "NF1") |> # Need to reduce dimensionality
  plot_outcomes(
    y_col = "ewr_achieved",
    y_lab = "All Arithmetic Mean",
    x_col = "map",
    colorgroups = NULL,
    colorset = "ewr_achieved",
    pal_list = list("scico::berlin"),
    facet_col = "scenario",
    facet_row = "env_obj",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    underlay_list = list(
      underlay = "basin",
      underlay_pal = "azure"
    )
  ) +
  ggplot2::theme(legend.position = "bottom")
```

While we can't have informative fill in multiple layers, we *can* have informative fill in polygons underlying point (gauge) data. Here, we include a fill in the underlay for SDL unit name (e.g. not a data fill, but still informative). It is hard to find palettes for the full set of catchments. The only discrete palette available that makes sense is `ggsci::default_igv`, and it's pretty garish. Using a continuous palette (e.g. `scico::oslo` ) works fine too, but the colors aren't very well spatially-separated. We need to come up with a default set that we like, I think. Could be as simple as an actual mapping of specific colors to catchments, a la `scene_pal`.

```{r}
agged_data$env_obj |> # for readability
  dplyr::filter(env_obj == "NF1") |> # Need to reduce dimensionality
  plot_outcomes(
    y_col = "ewr_achieved",
    y_lab = "All arithmetic mean",
    x_col = "map",
    colorgroups = NULL,
    colorset = "ewr_achieved",
    pal_list = list("scico::berlin"),
    facet_col = "scenario",
    facet_row = "env_obj",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    underlay_list = list(
      underlay = sdl_units,
      underlay_ycol = "SWSDLName",
      underlay_pal = "ggsci::default_igv"
    )
  ) +
  ggplot2::theme(legend.position = "bottom")
```

We can use a continuous variable on the underlay fill, but have to be careful to choose palettes that don't mask each other. We can also have multiple levels of underlay polygons (e.g. if we want the basin under sdl units). Note that we can pass colors directly, and not necessarily as a palette.

```{r}
agged_data$env_obj |> # for readability
  dplyr::filter(env_obj == "NF1") |> # Need to reduce dimensionality
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "map",
    colorgroups = NULL,
    colorset = "ewr_achieved",
    pal_list = list("ggthemes::Orange-Gold"),
    facet_col = "scenario",
    facet_row = "env_obj",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    underlay_list = list(
      list(
        underlay = "basin",
        underlay_pal = "cornsilk"
      ),
      list(
        underlay = dplyr::filter(obj_sdl_to_plot, env_obj == "NF1"),
        underlay_ycol = "ewr_achieved",
        underlay_pal = "scico::oslo"
      )
    )
  ) +
  ggplot2::theme(legend.position = "bottom")
```

We can also overlay, here with the sdl layer as 'primary', here with a single color to show where gauges are.

```{r}
obj_sdl_to_plot |>
  dplyr::filter(env_obj == "NF1") |> # Need to reduce dimensionality
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "map",
    colorgroups = NULL,
    colorset = "ewr_achieved",
    pal_list = list("scico::berlin"),
    facet_col = "scenario",
    facet_row = "env_obj",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    underlay_list = "basin",
    overlay_list = list(
      overlay = "bom_basin_gauges",
      overlay_pal = "grey40",
      clip = TRUE
    )
  ) +
  ggplot2::theme(legend.position = "bottom")
```

We can also give the overlay informative colors- this outcome is similar to what we've done above, but the amount of control we have over scaling etc differs depending on whether a layer is 'primary'. I intend to make this more general, but will need to be careful.

```{r}
obj_sdl_to_plot |>
  dplyr::filter(env_obj == "NF1") |> # Need to reduce dimensionality
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "map",
    colorgroups = NULL,
    colorset = "ewr_achieved",
    pal_list = list("scico::berlin"),
    facet_col = "scenario",
    facet_row = "env_obj",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    underlay_list = "basin",
    overlay_list = list(
      overlay = dplyr::filter(agged_data$env_obj, env_obj == "NF1"),
      overlay_pal = "scico::oslo",
      overlay_ycol = "ewr_achieved",
      clip = TRUE
    )
  ) +
  ggplot2::theme(legend.position = "bottom")
```

Here, we have a primary layer at the basin scale, overlay the sdl units with empty fill, and then put gauges on with informative values. There's clearly a lot we can do here with the layering, most of which has been tested, but isn't particularly interesting for a demonstration without a particular goal in mind.

```{r}
agged_data$mdb |>
  dplyr::filter(Objective %in% c(
    "Maintain water-dependent species richness",
    "Increase opportunities for colonial waterbird breeding*",
    "Support instream & floodplain productivity"
  )) |> # Need to reduce dimensionality
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "map",
    colorgroups = NULL,
    colorset = "ewr_achieved",
    pal_list = list("scico::oslo"),
    facet_col = "scenario",
    facet_row = "Objective",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    overlay_list = list(
      list(overlay = "sdl_units", overlay_pal = "black"),
      list(
        overlay = dplyr::filter(agged_data$env_obj, env_obj == "NF1"),
        overlay_pal = "ggthemes::Orange-Gold",
        overlay_ycol = "ewr_achieved"
      )
    )
  ) +
  ggplot2::theme(legend.position = "bottom")
```

As with the other plotting functions, we can compare to baseline using arbitrary functions, here `difference` to get the arithmetic change in outcomes. In both cases, the scale is fixed to be centered on the reference value (0 for difference, 1 for relative), and so using a diverging palette will make that centering clear.

```{r}
obj_sdl_to_plot |>
  dplyr::filter(env_group == "WB") |> # Need to reduce dimensionality
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "map",
    colorgroups = NULL,
    colorset = "ewr_achieved",
    pal_list = list("ggthemes::Orange-Blue-White Diverging"),
    facet_col = "env_obj",
    facet_row = "scenario",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "difference",
    group_cols = c("env_obj", "polyID"), # Do I need to group_by polyID for the maps? Yes. should probably automate that.
    underlay_list = list(underlay = basin, underlay_pal = "azure")
  )
```

And the `relative` change is likely to be the most informative and appropriate in many cases. We use the `add_eps` argument to add a small amount (half the minimum value) to zeros, otherwise we end up taking the log of 0.

```{r}
obj_sdl_to_plot |>
  dplyr::filter(env_group == "WB") |> # Need to reduce dimensionality
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "map",
    colorgroups = NULL,
    colorset = "ewr_achieved",
    pal_list = list("ggthemes::Orange-Blue-White Diverging"),
    facet_col = "env_obj",
    facet_row = "scenario",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    add_eps = min(obj_sdl_to_plot$ewr_achieved[obj_sdl_to_plot$ewr_achieved > 0],
      na.rm = TRUE
    ) / 2,
    zero_adjust = "auto",
    transy = "log10",
    group_cols = c("env_obj", "polyID"), # Do I need to group_by polyID for the maps? Yes. should probably automate that.
    underlay_list = list(underlay = basin, underlay_pal = "azure")
  )
```

# From presentation

## Input hydrographs

```{r}
#| echo: false
scenehydros <- read_hydro(hydro_dir, long = TRUE, format = "csv")

hydros <- plot_hydrographs(scenehydros, gaugefilter = c("412002", "422028", "421019", "421001"), colors = scene_pal)

hydros
```

## Maps and spatial scaling

```{r}
#| message: false
#| echo: false

# Quick plot
map_example <- agged_data$sdl_units |>
  dplyr::filter(env_obj == "NF1") |> # Need to reduce dimensionality
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "map",
    colorgroups = NULL,
    colorset = "ewr_achieved",
    pal_list = list("scico::berlin"),
    facet_col = "scenario",
    facet_row = "env_obj",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    underlay_list = "basin",
    overlay_list = list(
      overlay = dplyr::filter(
        agged_data$env_obj,
        env_obj == "NF1"
      ),
      overlay_pal = "scico::oslo",
      overlay_ycol = "ewr_achieved",
      clip = TRUE
    )
  ) +
  ggplot2::theme(legend.position = "bottom")

map_example
```

## Bars- SDL units and scenarios

SDL unit differences in all environmental objectives

```{r}
#| echo: false
catchcompare <- agged_data$sdl_units %>%
  group_by(SWSDLName, scenario) %>%
  summarise(ewr_achieved = sum(ewr_achieved, na.rm = TRUE)) %>%
  ungroup() %>%
  plot_outcomes(
    y_col = "ewr_achieved",
    colorset = "SWSDLName",
    pal_list = list("calecopal::lake"),
    sceneorder = sceneorder,
    position = "dodge"
  )

catchcompare
```

## Objective and scenario comparisons

::: panel-tabset
### Basin

```{r}
#| echo: false
objective_comp <- plot_outcomes(basin_to_plot,
  y_col = "ewr_achieved",
  x_col = "Objective",
  colorset = "scenario",
  scene_pal = scene_pal,
  sceneorder = sceneorder,
  position = "dodge"
)

objective_comp
```

### SDL units

```{r}
#| echo: false
#| message: false
# Create a palette list
env_pals <- list(
  EF = "grDevices::Purp",
  NF = "grDevices::Mint",
  NV = "grDevices::Burg",
  OS = "grDevices::Blues",
  WB = "grDevices::Peach"
)

# need to facet by space sdl unit and give it the colorgroup argument to take multiple palettes
sdl_stack <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    colorgroups = "env_group",
    colorset = "env_obj",
    pal_list = env_pals,
    facet_col = "SWSDLName",
    facet_row = ".",
    sceneorder = sceneorder
  )
sdl_stack
```
:::

## Lines and baseline

Change relative to baseline available to all plots

-   Disproportionate response

```{r}
#| echo: false

line_pals <- list(
  EF = "scico::acton",
  NF = "scico::bamako",
  NV = "scico::batlow",
  OS = "scico::lajolla",
  WB = "scico::hawaii"
)


sdl_line_groups_facet <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transy = "log10",
    color_lab = "Environmental\ngroup",
    colorgroup = "env_group",
    colorset = "env_obj",
    pal_list = line_pals,
    facet_row = "SWSDLName",
    facet_col = "env_group",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    add_eps = min(obj_sdl_to_plot$ewr_achieved[obj_sdl_to_plot$ewr_achieved > 0],
      na.rm = TRUE
    ) / 2,
    group_cols = c("env_obj", "polyID")
  )

sdl_line_groups_facet + ggplot2::theme(legend.position = "none")
```

## Fits

Smoothed fit of all environmental objectives in each group

-   Relative to baseline

```{r}
#| echo: false
#| message: false
sdl_fit_sdl <- obj_sdl_to_plot |>
  plot_outcomes(
    y_col = "ewr_achieved",
    x_col = "delta",
    y_lab = "Proportion met",
    x_lab = "Change in flow",
    transx = "log10",
    transy = "log10",
    color_lab = "SDL unit",
    colorset = "SWSDLName",
    pal_list = list("ggsci::default_jama"),
    facet_wrapper = "env_group",
    scene_pal = scene_pal,
    sceneorder = sceneorder,
    base_lev = "base",
    comp_fun = "relative",
    add_eps = min(obj_sdl_to_plot$ewr_achieved[obj_sdl_to_plot$ewr_achieved > 0],
      na.rm = TRUE
    ) / 2,
    group_cols = c("env_obj", "polyID"),
    smooth = TRUE
  )

suppressWarnings(print(sdl_fit_sdl))
```

## Causal networks

::: panel-tabset
```{r}
#| echo: false
# Which steps are theme? This glosses over potential changes with space
themesteps <- purrr::map_lgl(aggseq, is.character)


themeseq <- aggseq[themesteps]

# If there were more than 1 aggfun per step, we'd need to choose one
themefuns <- funseq[themesteps]

ewr_edges <- make_edges(
  dflist = causal_ewr,
  fromtos = themeseq[2:length(themeseq)],
  gaugefilter = "421001"
)

nodes <- make_nodes(ewr_edges)
```

```{r}
#| message: false
#| warning: false
#| echo: false

# What is the column that defines the value?
valcol <- "ewr_achieved"

# Get the values for each node
targetlevels <- names(themesteps)[themesteps]

aggvals <- extract_vals_causal(agged_data, themefuns, valcol,
  targetlevels = targetlevels
)

# cut to relevant gauge (or no gauge for higher spatial levels)
# THis is slow- I think what we'd actually do is find the matching sdl and cut to that earlier
gaugematch <- st_intersects(bom_basin_gauges[bom_basin_gauges$gauge == "421001", ], aggvals, sparse = FALSE)

aggvals <- aggvals[as.vector(gaugematch), ] |>
  st_drop_geometry()
# aggvals <- aggvals %>% dplyr::filter(gauge == '421001' | is.na(gauge)) %>%
#   dplyr::select(-gauge)

# join to the nodes
nodes_with_vals <- nodes |>
  dplyr::filter(NodeType != "ewr_code_timing") |>
  dplyr::left_join(aggvals) |>
  dplyr::filter(!is.na(scenario))
```

### Down 4

```{r}
#| echo: false
aggNetworkdown <- make_causal_plot(
  nodes = dplyr::filter(
    nodes_with_vals,
    scenario == "down2"
  ),
  edges = ewr_edges,
  edge_pal = "black",
  node_pal = list(value = "scico::tokyo"),
  node_colorset = "ewr_achieved",
  render = FALSE
)

DiagrammeR::render_graph(aggNetworkdown)
```

### Baseline

```{r}
#| echo: false
aggNetworkbase <- make_causal_plot(
  nodes = dplyr::filter(
    nodes_with_vals,
    scenario == "base"
  ),
  edges = ewr_edges,
  edge_pal = "black",
  node_pal = list(value = "scico::tokyo"),
  node_colorset = "ewr_achieved",
  render = FALSE
)

DiagrammeR::render_graph(aggNetworkbase)
```

### Up 4

```{r}
#| echo: false
aggNetworkup <- make_causal_plot(
  nodes = dplyr::filter(
    nodes_with_vals,
    scenario == "up2"
  ),
  edges = ewr_edges,
  edge_pal = "black",
  node_pal = list(value = "scico::tokyo"),
  node_colorset = "ewr_achieved",
  render = FALSE
)

DiagrammeR::render_graph(aggNetworkup)
```
:::
