---
title: "Bar plots"
author: "Galen Holt"
---

```{r}
#| message: false
library(HydroBOT)
library(ggplot2)
library(dplyr)
library(sf)
```

::: callout-note
HydroBOT outputs are usually `sf` objects. To use any of their geographic properties (and prevent unexpected behaviour), we need to have `sf` loaded. This should happen automatically with `library(HydroBOT)`, but if HydroBOT is used with `::`, it may not be, and so for safety we use `library(sf)`.
:::

# Overview

This notebook provides examples of creating bar plots, e.g. plots with one quantitative y-axis for outcome, and a qualitative x-axis. The x-axis is often, but not always, the scenarios. We also demonstrate here the ability to use color and different color palettes to include additional information, including spatial unit or type of response.

For a quantitative x-axis, we would typically use [line plots](../comparer/line_plots.qmd).

# Demonstration setup

As usual, we need paths to the data. We use the 'more scenarios' examples for all the plots, with processing as in the [website workflow](/workflows/run_hydrobot_website.qmd).

```{r}
project_dir <- file.path("more_scenarios")
hydro_dir <- file.path(project_dir, "hydrographs")
agg_dir <- file.path(project_dir, "aggregator_output")
```

## Scenario information

The 'scenarios' used here for examples are a factorial combination of multiplicative and additive changes to  flow, based on historical hydrographs.

In an ideal world, scenario metadata would be auto-acquired from the directory defining the hydrographs. In practice, that's rarely available, but we can read it in here and make some small modifications for readability.

```{r}
scenarios <- jsonlite::read_json(file.path(
  hydro_dir,
  "scenario_metadata.json"
)) |>
  tibble::as_tibble() |>
  tidyr::unnest(cols = everything()) |> 
  dplyr::rename(scenario = scenario_name) |> 
  dplyr::arrange(flow_addition, flow_multiplier) |> 
  mutate(climate_code = LETTERS[1:n()], .by = flow_addition) |>
  mutate(adapt_code = 1:n(), .by = flow_multiplier)
```

To scale flow, we apply nine flow multipliers, ranging from 0.5 to 2.0, to the historical hydrographs (SI @tbl-scenarios). We refer to these as 'climate' scenarios, reflecting a common representation where entire hydrographs might shift to represent climate change. To achieve pulsed change for each of the 'climate' scenarios, four flow additions were applied including 1) no addition (baseline), 2) addition of 250 ML/d, 3) addition of 6500 ML/d, and 4) addition of 12000 ML/d (@tbl-scenarios). These additional flows were added throughout the period of September to December. We refer to these scenarios as 'climate adaptations' because management options are often available in the form of altering water availability for short time periods through mechanisms like water releases, though the options here do not represent proposed actions. These scenarios should not be interpreted as potential climate impacts or adaptations, but instead as different ways flows might change (multiplicative or additive) and different magnitudes of change.

```{r}
#| label: tbl-scenarios
#| width: 4
#| tbl-cap: Demonstration scenarios are a factorial combination of 'climate' (scaled flow) and 'adaptation' (pulsed additions).
#| message: false

adapt_scenes <- scenarios |> 
  filter(scenario != 'MAX') |> 
  mutate(flow_addition = as.integer(flow_addition)) |> 
  select(`Adaptation code` = adapt_code,
         `Flow addition (ML/d)` = flow_addition) |>
  distinct()

climate_scenes <- scenarios |> 
  filter(scenario != 'MAX') |> 
  select(`Climate code` = climate_code,
         `Flow multiplier` = flow_multiplier) |>
  distinct()

adapt_scenes <- adapt_scenes |> 
  bind_rows(tibble(`Adaptation code` = rep(NA, nrow(climate_scenes) - 
                                             nrow(adapt_scenes)),
       `Flow addition (ML/d)` = rep(NA, nrow(climate_scenes) - 
                                      nrow(adapt_scenes))))

climate_scenes |> 
               mutate(`Flow multiplier` = signif(`Flow multiplier`, 2)) |> 
  bind_cols(adapt_scenes) |> 
  flextable::flextable()  |> 
  flextable::font(fontname = 'Calibri') |> 
  flextable::fontsize(size = 10, part = 'all') |> 
  flextable::set_table_properties(layout = "autofit", width = 1) |> 
  flextable::vline(j = 2)

```


## Read in the data

We read in the example data we will use for all plots.

```{r}
agged_data <- readRDS(file.path(agg_dir, "achievement_aggregated.rds"))
```

That has all the steps in the aggregation, but most of the plots here will only use a subset to demonstrate.

To make visualisation easier, the SDL units data is given a grouping column that puts the many `env_obj` variables in groups defined by their first two letters, e.g. `EF` for Ecosystem Function. These correspond to the 'Target' level, but it can be useful to have the two groupings together for some examples.

If we had used multiple aggregation functions at any step, we should filter down to the one we want here, but we only used one for this example.

For simplicity here, we will only look at a small selection of the scenarios (multiplicative changes of 0.5,1, and 2). Thus, we make two small dataframes for our primary examples here.

```{r}
scenarios_to_plot <- c('climatedown2adapt0', 'climatebaseadapt0', 'climateup2adapt0')

basin_to_plot <- agged_data$mdb |> 
  dplyr::filter(scenario %in% scenarios_to_plot) |> 
  dplyr::left_join(scenarios, by = 'scenario')

# Create a grouping variable
obj_sdl_to_plot <- agged_data$sdl_units |>
    dplyr::filter(scenario %in% scenarios_to_plot) |> 
  dplyr::mutate(env_group = stringr::str_extract(env_obj, "^[A-Z]+")) |>
  dplyr::arrange(env_group, env_obj) |> 
  dplyr::left_join(scenarios, by = 'scenario')
```

# Standard scenario appearance

We will typically have a consistent look for the scenarios across the project, with a logical ordering and standard colors. Such standard colors are not included in the {HydroBOT} package because they are project/analysis- specific, but they could be set at project-level, e.g. in the `.Rprofile`, if desired.

Here, we use the special arguments `refvals` and `refcols` to make a color palette from a standard {paletter} option ("ggsci::nrc_npg") while setting a specific level to a specified value. We will use the codes (see @tbl-scenarios) rather than the names to make plots readable.

There is a `sceneorder` argument to `plot_outcomes()` that lets us explicitly set the order of the scenarios. However, it is typically easiest to simply make the scenarios a factor, though we use the sceneorder here. It operates *only* on a column named 'scenario', though, so if other columns need to be ordered they should be made factors before feeding to `plot_outcomes()`. 

```{r}
sceneorder <- forcats::fct_reorder(basin_to_plot$scenario,
                                   basin_to_plot$flow_multiplier)

scene_pal <- make_pal(unique(basin_to_plot$climate_code),
  palette = "ggsci::nrc_npg",
  refvals = "E", refcols = "black"
)

scene_pal
```

# Make bar plots

## Scenario fills

### Basin scale

We can make plots looking at how scenarios differ for each of the outcome categories for a simple case of only one outcome. This uses `facet_wrapper` to just wrap the single facet axis.

The `colorset` argument is the column that determines color, while the `pal_list` defines those colors, here as a named `colors` object, but as we see below it can also be palette names. 

```{r}
#| message: false
plot_outcomes(basin_to_plot,
  outcome_col = "ewr_achieved",
  x_col = 'climate_code',
  facet_wrapper = "Target",
  colorset = "climate_code",
  pal_list = scene_pal,
  sceneorder = sceneorder
)
```

HydroBOT retains the axis names as-is from the incoming dataframe, as they provide the true meaning of each value. But we can change them, either inside the `plot_outcomes()` function (here for y) or post-hoc with `ggplot2::labs()` (here for x). We can also set the `sceneorder` with a character vector if that's easier than setting up a Factor or if we want to change them around for some reason. Because the outputs of `plot_outcomes()` are just ggplot objects, changing the labels outside the function can be very useful for checking that each axis is in fact what we think it is before giving it clean labels.

```{r}
#| message: false
plot_outcomes(basin_to_plot,
  outcome_col = "ewr_achieved",
  y_lab = "Proportion Objectives\nAchieved",
  x_col = 'climate_code',
  color_lab = "Scenario",
  facet_wrapper = "Target",
  colorset = "climate_code",
  pal_list = scene_pal,
  sceneorder = c('climateup2adapt0', 'climatebaseadapt0', 'climatedown2adapt0')
) +
  labs(x = 'Scenario')
```
Another approach is to put other groupings on the x-axis, and color by scenario. 

```{r}
#| message: false
plot_outcomes(basin_to_plot,
  outcome_col = "ewr_achieved",
  x_col = "Target",
  colorset = "climate_code",
  pal_list = scene_pal,
  sceneorder = sceneorder
)
```

We can pass `position = 'dodge'` to use dodged bars for clearer comparisons, particularly accentuating the variation in sensitivity of the different outcomes to the scenarios.

```{r}
#| message: false
plot_outcomes(basin_to_plot,
  outcome_col = "ewr_achieved",
  x_col = "Target",
  colorset = "climate_code",
  pal_list = scene_pal,
  sceneorder = sceneorder,
  position = 'dodge'
)
```

### SDL units

We can use the aggregation step of `env_obj` and SDL units to demonstrate plotting that not only addresses the outcomes for scenarios, but how they differ across space.

First, we look at how the different scenarios perform for the Ecosystem Function objectives in each SDL unit. We also use the `ggplot2` functionality to remove the x-axis label, since it is redundant with the color. 

::: callout-tip
Often when we have multiple dimensions, we'll want to do a simple filter to relevant subsets of the data for readability. When this filtering occurs, it is almost always a good idea to do it on the fly (as here), to avoid errors associated with losing track of data manipulations and instead start each figure with the full dataset. 
:::

```{r}
#| message: false
obj_sdl_to_plot |>
  filter(grepl("^EF", env_obj)) |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    facet_col = "env_obj",
    facet_row = "SWSDLName",
    colorset = "climate_code",
    pal_list = scene_pal,
    sceneorder = sceneorder
  ) +
  theme(axis.text.x = element_blank(), axis.title.x = element_blank())
```

We address a few ways to handle groups of outcome variables, one of the simplest is to simply facet these plots by those groups, with all the outcomes in the group getting their own bars. This puts the theme levels on x and colors by scenario, with the groups accentuated by facets. These can be stacked (`position = 'stack'`- the default) or dodged (demonstrated here).

```{r}
dodgefacet <- obj_sdl_to_plot |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    x_col = "env_obj",
    colorset = "climate_code",
    facet_row = "SWSDLName",
    facet_col = "env_group",
    scales = "free_x",
    pal_list = scene_pal,
    sceneorder = sceneorder,
    position = "dodge"
  )

dodgefacet + theme(legend.position = "bottom") +
  labs(x = "Environmental Objective")
```

# Colors from outcomes

Rather than facetting, we can stack each of the outcome categories (here, Target groups). To do this, we simply change the `colorset` to "Target" instead of 'scenario' (the default `x_col` is scenario, so it remains on x, but it is generally better to specify it explicitly. This is especially true here, where the 'climate_code' column is a better description). We also change the `pal_list` to a {paletteer} name, providing the palette from which to choose colors for each Target. If we wanted to retain these colours across the project, we would define a palette for the Targets as we did above for scenarios.

This yields a more compact plot (@fig-color-target) that shows overall outcomes without as much duplication. The stacking here of the `env_obj` outcomes in each group while coloring them all the same is itself a sort of simple aggregation. The approach next with `position = "dodge"` is generally better (@fig-sdl-dodge).

```{r}
#| message: false
#| label: fig-color-target
plot_outcomes(basin_to_plot,
  outcome_col = "ewr_achieved",
  colorset = "Target",
  pal_list = list("scico::tokyo"),
  sceneorder = sceneorder
) +
  guides(fill = guide_legend(ncol = 2)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
```

In another example of colors from other information in the data, when we have multiple spatial units we might color by them instead of coloring by outcome category. Here, we show how to color by SDL unit (SWSDLName) instead of `env_obj`. We also explicitly use `x_col` to use climate code and not the full names.

```{r}
#| message: false
#| label: fig-sdl-dodge
plot_outcomes(obj_sdl_to_plot,
  outcome_col = "ewr_achieved",
  x_col = 'climate_code',
  colorset = "SWSDLName",
  pal_list = list("ggsci::default_jama"),
  sceneorder = sceneorder
)
```

That shows that while all SDL units are affected by the changes in the flow, the Lachlan is less sensitive.

We can also use `position = 'dodge'` to have side-by-side bars instead of stacked (@fig-summed). Note that in this case, where we're coloring by SDL unit but there are many `env_obj` values, those `env_obj` no longer stack, and so we have to manually stack them by calculating their sum. This would not be the case if we were coloring by individual rows (`env_obj`)- see examples of that below.

```{r}
#| message: false
#| label: fig-summed
obj_sdl_to_plot |>
  group_by(SWSDLName, scenario) |>
  summarise(ewr_achieved = sum(ewr_achieved, na.rm = TRUE)) |>
  ungroup() |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    colorset = "SWSDLName",
    pal_list = list("ggsci::default_jama"),
    sceneorder = sceneorder,
    position = "dodge"
  )
```

If we have multiple levels of groupings, we can color by the groups directly if we don't care what the individual `env_obj`s are doing between them. This is very similar to the plots coloring by SDL unit above.

```{r}
plot_outcomes(obj_sdl_to_plot,
  outcome_col = "ewr_achieved",
  x_col = 'climate_code',
  colorset = "env_group",
  pal_list = list("scico::berlin"),
  facet_col = "SWSDLName",
  sceneorder = sceneorder
) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
```

## Grouped colors

HydroBOT can assign different color palettes to different sets of outcomes, yielding what is essentially another axis on which we can plot information. We use this same ability across a number of plot types, particularly [causal networks](/provided_data/causal_plots.qmd). For example, we might categorize the `env_obj` outcomes into the larger scale groups (e.g. 'NF', 'EF', etc). We can then assign each of these a separate palette, and so the individual `env_obj`s get different colors chosen from different palettes.

Achieving this requires specifying two columns- the `colorset`, as above, is the column that determines color. The `colorgroups` column specifies the groupings of those `colorset` values, and so what palette to use. Thus, the `pal_list` needs to be either length 1 (everything gets the same palette) or `length(unique(data$colorgroups))`. Note also that the `colorset` values must be unique to `colorgroups`- this cannot be a one-to-many mapping because each `colorset` value must get a color from a single palette defined by the `colorgroup` it is in.

We demonstrate with `env_obj` variables mapped to larger environmental groups, making it easier to see at a glance the sorts of environmental objectives that are more or less affected, while also allowing views of the individual environmental objectives. Here we use `facet_col` and `facet_row` to ensure the SDL units don't wrap around. We made the `env_groups` column when we chose the data initially.

```{r}
#| message: false

# Create a palette list
env_pals <- list(
  EF = "grDevices::Purp",
  NF = "grDevices::Mint",
  NV = "grDevices::Burg",
  OS = "grDevices::Blues",
  WB = "grDevices::Peach"
)

# need to facet by space sdl unit and give it the colorgroup argument to take multiple palettes
obj_sdl_to_plot |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    x_col = 'climate_code',
    colorgroups = "env_group",
    colorset = "env_obj",
    pal_list = env_pals,
    facet_col = "SWSDLName",
    facet_row = "."
  ) +
  theme(legend.key.size = unit(0.5, 'cm'))
```

Adding facetting by those groups can make that easier to read if the goal is to focus on changes within groups, but more plots.

```{r}
#| message: false

obj_sdl_to_plot |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    x_col = 'climate_code',
    colorgroups = "env_group",
    colorset = "env_obj",
    pal_list = env_pals,
    facet_col = "SWSDLName",
    facet_row = "env_group"
  ) + 
  theme(legend.key.size = unit(0.5, 'cm'))
```

We could also split those bars sideways instead of stack them, but that likely makes more sense if there are fewer categories than here. We again use `position = 'dodge'`, but now we don't need to sum because we're stacking each row already. I've flipped the facetting and taken advantage of the fact that these are just ggplot objects to remove the legend, making it very slightly easier to read (but harder to interpret). This gets very crowded with the full set of scenarios, so we can use the `scenariofilter` argument to cut it to just a few (here, base and multiply and divide by 1.5).

```{r}
#| message: false

obj_sdl_to_plot |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    x_col = 'climate_code',
    colorgroups = "env_group",
    colorset = "env_obj",
    pal_list = env_pals,
    facet_col = "SWSDLName",
    facet_row = "env_group",
    position = 'dodge'
  ) +
  theme(legend.key.size = unit(0.5, 'cm'))
```

Another approach to groups of outcomes without the colors explicitly grouped is to not use `colorgroup`, but instead just facet by the group and give every `colorset` value a color from the same palette. Depending on the palette chosen and the breaks, this can be quicker, but will not accentuate groups as well.

```{r}
#| message: false
obj_sdl_to_plot |>
  plot_outcomes(
    outcome_col = "ewr_achieved",
    colorgroups = NULL,
    colorset = "env_obj",
    pal_list = list("scico::berlin"),
    facet_row = "SWSDLName",
    facet_col = "env_group",
    scales = "free_x"
  ) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
```

These plots are interesting, but in typical use, the plots above using facets for the groups or coloring by the groups themselves are likely to be easier to read, unless we really are interested in this level of granularity. Whatever approach we choose for a given plot, accentuating the differences between outcome groups can be a powerful interpretation tool.

## Manual color definition

Though the above examples using {paletteer} palettes are the easiest way to specify coloring, we don't have to let the palettes auto-choose colors, and can instead pass `colors` objects, just as we do for scenarios. This can be particularly useful with small numbers of groups (defining too many colors is cumbersome- that's what palettes are for) when we want to control which is which. Just as with scenarios, we use `make_pal()`. Here, we will use `'scico::berlin'` as the base, but define several 'reference' values manually. This demonstration uses `includeRef = TRUE` so we *replace* the palette values with the refs, rather than choose them from the set of values with refs removed. This tends to yield better spread of colors (and lets us sometimes ref colors and sometimes not if we also used `returnUnref`). For example, maybe we want to sometimes really accentuate ecosystem function and native vegetation, but not in all plots.

First, we create the palettes with and without the (garish) ref values.

```{r}
obj_pal <- make_pal(
  levels = unique(obj_sdl_to_plot$env_group),
  palette = "scico::lisbon",
  refvals = c("EF", "NV"), refcols = c("purple", "orange"), includeRef = TRUE, returnUnref = TRUE
)
```

Then we can create an accentuated plot sometimes, if, perhaps, we want to highlight how EF performed.

```{r}
#| message: false
plot_outcomes(obj_sdl_to_plot,
  outcome_col = "ewr_achieved",
  x_col = 'climate_code',
  colorset = "env_group",
  pal_list = obj_pal$refcols,
  facet_col = "SWSDLName",
  facet_row = ".",
  sceneorder = sceneorder
) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
```

But for other plots maybe we don't want that accentuation and we can use the `unrefcols` to retain the standard coloring- note that 'NF', 'OS', and 'WB' colors are unchanged.

```{r}
#| message: false
plot_outcomes(obj_sdl_to_plot,
  outcome_col = "ewr_achieved",
  x_col = 'climate_code',
  colorset = "env_group",
  pal_list = obj_pal$unrefcols,
  facet_col = "SWSDLName",
  facet_row = ".",
  sceneorder = sceneorder
) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5))
```
