---
title: "Getting started"
format: html
---

## Installing HydroBOT

The {HydroBOT} package needs to be installed to provide all functions used here. It also provides some necessary data for the causal network relationships, and canonical shapefiles that have been prepped.

Installation is slightly more complex than the usual `devtools::install_github(MDBAuth/HydroBOT)` because the repo is private. The SSH method seems to be the most robust, though https with a github PAT is often the recommendation for private repos. In general, just use the below. A [template repo](https://github.com/MDBAuth/toolkit_use) is available, however, with necessary setup scripts and test notebooks for a range of systems and uses.

-   To set up SSH, go to the github instructions [here](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent) and then [here](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account)

-   To set up a PAT, {usethis} has a good [walkthrough](https://usethis.r-lib.org/articles/git-credentials.html).

```{r}
#| warning: false
#| message: false
#| eval: false

# GITHUB INSTALL
# SSH- seems most stable

devtools::install_git("git@github.com:MDBAuth/HydroBOT.git",
                      ref = 'master', force = TRUE, upgrade = 'ask')

# HTTPS- may work, if you have gitcreds and a PAT set up
# activate the PAT
gitcreds::gitcreds_get()
renv::install('MDBAuth/HydroBOT')

# pak also requires a PAT
pak::pkg_install('MDBAuth/HydroBOT')

```

Load the package

```{r}
#| eval: false
library(HydroBOT)
```

## Example workflow

The basic workflow is to point to the hydrographs and run the modules in the [controller](controller/controller_overview.qmd), then scale the outcomes in the [aggregator](aggregator/aggregation_overview.qmd), and synthesise outputs with the [comparer](comparer/comparer_overview.qmd). More details are available at those links, and several [different workflows are demonstrated](workflows/workflow_overview.qmd) as well; a simple example follows.

### Controller

We need to tell HydroBOT where the hydrographs are, as well as pass some minimal parameters to the EWR tool. We also typically save the results out, since running each step can take a while.

```{r}
#| message: false
hydro_dir <- system.file('extdata/testsmall/hydrographs', package = 'HydroBOT')

project_dir <- tempdir()

# Generated data
# EWR outputs (will be created here in controller, read from here in aggregator)
ewr_results <- file.path(project_dir, 'module_output', 'EWR')

# outputs of aggregator. There may be multiple modules
agg_results <- file.path(project_dir, 'aggregator_output')
```

We need the 'yearly' EWR outputs for HydroBOT processing, though we can get the EWR to return any of its options.

```{r}
#| message: false
ewr_out <- prep_run_save_ewrs(hydro_dir = hydro_dir, 
                              output_parent_dir = tempdir(), 
                              outputType = list('yearly'),
                              returnType = list('yearly'))
```

### Aggregation

We need to define an aggregation sequence, which specifies the steps along space, time, and value dimensions, as well as a matching sequence of aggregation functions at each step. The example here is a reasonable default for many situations, but should be considered carefully. Please see the [aggregator section](aggregator/aggregation_overview.qmd) for a detailed treatment of the syntax and capabilities of these sequences.

For this example, if any of the 'versions' of an EWR pass, say it passes in step 2. If we think the 'versions' are actually separate EWRs for different purposes, we might use 'ArithmeticMean' in step 2 intead.

```{r}
aggseq <- list(all_time = 'all_time',
               ewr_code = c('ewr_code_timing', 'ewr_code'),
               sdl_units = sdl_units,
               env_obj =  c('ewr_code', "env_obj"),
               Target = c('env_obj', 'Target'),
               mdb = basin,
               target_5_year_2024 = c('Target', 'target_5_year_2024'))

funseq <- list('ArithmeticMean', 
               'CompensatingFactor',
               'ArithmeticMean',
               'ArithmeticMean',
               'ArithmeticMean',
               'SpatialWeightedMean',
               'ArithmeticMean')

```

Run the aggregation. Use the `auto_ewr_PU` shortcut to auto-specify some needed grouping for EWR outputs (see [here](aggregator/psuedo_spatial_group_until.qmd) for more detail).

Read the messages. Most of these are saying it's more explicit to avoid `auto_ewr_PU = TRUE`, but there are also messages saying that the causal network is missing links.

```{r}
aggout <- read_and_agg(datpath = ewr_results, 
             type = 'achievement',
             geopath = bom_basin_gauges,
             causalpath = causal_ewr,
             groupers = 'scenario',
             aggCols = 'ewr_achieved',
             auto_ewr_PU = TRUE,
             aggsequence = aggseq,
             funsequence = funseq,
             saveintermediate = TRUE,
             namehistory = FALSE,
             keepAllPolys = FALSE,
             returnList = TRUE,
             add_max = FALSE,
             savepath = agg_results)
```

### Comparer

Now we can make a couple quick plots to see what we've made. For more detail about plotting options and controls, see the [comparer](comparer/comparer_overview.qmd).

#### Maps and spatial scaling

```{r}
#| message: false

# Quick plot
map_example <- aggout$env_obj |>
  dplyr::filter(env_obj == 'NF1') |> # Need to reduce dimensionality
  plot_outcomes(outcome_col = 'ewr_achieved',
                plot_type = 'map',
                colorset = 'ewr_achieved',
                pal_list = list('scico::berlin'),
                facet_col = 'scenario',
                facet_row = 'env_obj',
                sceneorder = c('down4', 'base', 'up4'),
                underlay_list = 'basin') +
  ggplot2::theme(legend.position = 'bottom')

map_example
```

## Bars- SDL units and scenarios

SDL unit differences across all environmental objectives

```{r}
#| echo: false
catchcompare <- aggout$env_obj %>% 
plot_outcomes(outcome_col = 'ewr_achieved',
              colorset = 'SWSDLName',
              pal_list = list("calecopal::lake"),
              sceneorder = c('down4', 'base', 'up4'),
              position = 'dodge')

catchcompare
```
