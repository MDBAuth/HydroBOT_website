---
title: "Saving each step"
editor: visual
params:
  REBUILD_DATA: FALSE
---

A common way to run HydroBOT is to use a single document (i.e. not running the Controller, Aggregator, and Comparer as separate notebooks), but save the outputs at each step. This allows re-starting analyses if necessary and is particularly useful for large jobs, especially if batching over many scenarios. That said, in practice, once batching takes more than several minutes per stage, it often does make most sense to split into separate notebooks or scripts for each step.

Retaining everything in-memory is a very simple flip of a switch, demoed in [its own doc](/workflows/workflow_in_memory.qmd).

The [getting started page](../getting_started.qmd) uses this sort of workflow.

```{r}
library(HydroBOT)
```


## Directories

Here, we will use the example hydrographs that come with HydroBOT.

*Normally* `project_dir` and `hydro_dir` would point somewhere external (and typically, having `hydro_dir` inside `project_dir` will make life easier).

```{r}
#| message: false
hydro_dir <- system.file('extdata/testsmall/hydrographs', package = 'HydroBOT')

project_dir <- file.path('test_dir')

# Generated data
# EWR outputs (will be created here in controller, read from here in aggregator)
ewr_results <- file.path(project_dir, 'module_output', 'EWR')

# outputs of aggregator. There may be multiple modules
agg_results <- file.path(project_dir, 'aggregator_output')
```

We need the 'yearly' EWR outputs for HydroBOT processing, though we can get the EWR to return any of its options.

```{r}
#| message: false
#| label: run-ewr
ewr_out <- prep_run_save_ewrs(hydro_dir = hydro_dir, 
                              output_parent_dir = project_dir, 
                              outputType = list('yearly'),
                              returnType = list('yearly'))
```

## Aggregation

We need to define an aggregation sequence, which specifies the steps along space, time, and value dimensions, as well as a matching sequence of aggregation functions at each step. The example here is a reasonable default for many situations, but should be considered carefully. Please see the [aggregator section](../aggregator/aggregation_overview.qmd) for a detailed treatment of the syntax and capabilities of these sequences.

For this example, if any of the 'versions' of an EWR pass, say it passes in step 2. If we think the 'versions' are actually separate EWRs for different purposes, we might use 'ArithmeticMean' in step 2 intead.

```{r}
#| label: aggseqs
aggseq <- list(all_time = 'all_time',
               ewr_code = c('ewr_code_timing', 'ewr_code'),
               sdl_units = sdl_units,
               env_obj =  c('ewr_code', "env_obj"),
               Target = c('env_obj', 'Target'),
               mdb = basin,
               target_5_year_2024 = c('Target', 'target_5_year_2024'))

funseq <- list('ArithmeticMean', 
               'CompensatingFactor',
               'ArithmeticMean',
               'ArithmeticMean',
               'ArithmeticMean',
               'SpatialWeightedMean',
               'ArithmeticMean')

```

Run the aggregation. Use the `auto_ewr_PU` shortcut to auto-specify some needed grouping for EWR outputs (see [here](../aggregator/psuedo_spatial_group_until.qmd) for more detail).

Read the messages. Most of these are saying it's more explicit to avoid `auto_ewr_PU = TRUE`, but there are also messages saying that the causal network is missing links.

```{r}
#| label: run-agg
aggout <- read_and_agg(datpath = ewr_results, 
             type = 'achievement',
             geopath = bom_basin_gauges,
             causalpath = causal_ewr,
             groupers = 'scenario',
             aggCols = 'ewr_achieved',
             auto_ewr_PU = TRUE,
             aggsequence = aggseq,
             funsequence = funseq,
             saveintermediate = TRUE,
             namehistory = FALSE,
             keepAllPolys = FALSE,
             returnList = TRUE,
             add_max = FALSE,
             savepath = agg_results)
```

## Comparer

Now we can make a couple quick plots to see what we've made. For more detail about plotting options and controls, see the [comparer](../comparer/comparer_overview.qmd).

### Maps and spatial scaling

```{r}
#| message: false
#| label: map
map_example <- aggout$env_obj |>
  dplyr::filter(env_obj == 'NF1') |> # Need to reduce dimensionality
  plot_outcomes(outcome_col = 'ewr_achieved',
                plot_type = 'map',
                colorset = 'ewr_achieved',
                pal_list = list('scico::berlin'),
                facet_col = 'scenario',
                facet_row = 'env_obj',
                sceneorder = c('down4', 'base', 'up4'),
                underlay_list = 'basin') +
  ggplot2::theme(legend.position = 'bottom')

map_example
```

### Bars- SDL units and scenarios

SDL unit differences across all environmental objectives

```{r}
#| label: bar
catchcompare <- aggout$env_obj %>% 
plot_outcomes(outcome_col = 'ewr_achieved',
              colorset = 'SWSDLName',
              pal_list = list("calecopal::lake"),
              sceneorder = c('down4', 'base', 'up4'),
              position = 'dodge')

catchcompare
```

